"""
CASL Code Generator - Bytecode Emission Backend

This module implements the code generation phase for CASL (Code Analysis Specification
Language), transforming CASL AST nodes into abstract bytecode IR compatible with the
cppcheckdata-shims abstract interpretation framework.

Architecture:
    CASL Source → Parser → AST → **CodeGen** → FunctionCode/AbstractProgram → Execution

The generated bytecode uses the InstructionBuilder emission patterns and produces
FunctionCode structures that integrate with:
    - CheckerRegistry for registration
    - AbstractInterpreter for execution
    - Diagnostic infrastructure for reporting

Design Principles:
    1. Bytecode IR emission (NOT Python source generation)
    2. Compatible with InstructionBuilder patterns
    3. Direct integration with Checker lifecycle (collect_evidence/diagnose/report)
    4. State machine compilation for temporal properties
    5. Query compilation for CSQL pattern matching

Citation: Based on cppcheckdata-shims-source-code.md infrastructure:
    - InstructionBuilder (lines 11656-11864)
    - FunctionCode (lines 9705-9788)
    - AbstractProgram (lines 9792-9839)
    - Checker base class (lines 16831-16970)
"""

from __future__ import annotations

import itertools
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import (
    Any,
    Callable,
    Dict,
    Generic,
    Iterator,
    List,
    Mapping,
    Optional,
    Protocol,
    Sequence,
    Set,
    Tuple,
    Type,
    TypeVar,
    Union,
    cast,
)

# =============================================================================
# Forward declarations for integration with cppcheckdata-shims types
# These would be imported from the actual module in production
# =============================================================================

# From bytecode infrastructure (lines 9649-9839)
@dataclass(slots=True)
class Reg:
    """Register reference in abstract bytecode."""
    name: str
    
    def __hash__(self) -> int:
        return hash(self.name)
    
    def __eq__(self, other: object) -> bool:
        if isinstance(other, Reg):
            return self.name == other.name
        return False


@dataclass(slots=True)
class BlockRef:
    """Reference to a basic block by ID."""
    block_id: int


@dataclass(slots=True)
class EventRef:
    """Reference to an event emission point."""
    event_id: str
    params: Tuple[Any, ...] = ()


@dataclass(slots=True)
class ObserverRef:
    """Reference to an observer/monitor."""
    observer_id: str
    watched_regs: Tuple[Reg, ...] = ()


class Opcode(Enum):
    """Abstract bytecode opcodes."""
    # Data movement
    LOAD_CONST = auto()
    LOAD_REG = auto()
    STORE_REG = auto()
    LOAD_ATTR = auto()
    STORE_ATTR = auto()
    LOAD_GLOBAL = auto()
    STORE_GLOBAL = auto()
    
    # Arithmetic/Logic
    BINARY_OP = auto()
    UNARY_OP = auto()
    COMPARE = auto()
    
    # Control flow
    JUMP = auto()
    BRANCH = auto()
    CALL = auto()
    RETURN = auto()
    
    # Events and observation (CASL-specific)
    EVENT = auto()
    OBSERVE = auto()
    ENTER_SCOPE = auto()
    EXIT_SCOPE = auto()
    
    # State machine operations
    STATE_TRANSITION = auto()
    STATE_CHECK = auto()
    EMIT_DIAGNOSTIC = auto()
    
    # Query operations
    MATCH_START = auto()
    MATCH_BIND = auto()
    MATCH_FILTER = auto()
    MATCH_YIELD = auto()
    
    # Misc
    NOP = auto()
    PHI = auto()


@dataclass(slots=True)
class Instruction:
    """Single abstract bytecode instruction."""
    opcode: Opcode
    operands: Tuple[Any, ...] = ()
    source_line: Optional[int] = None
    source_column: Optional[int] = None
    
    def regs_defined(self) -> Set[Reg]:
        """Return set of registers defined by this instruction."""
        defined: Set[Reg] = set()
        if self.opcode in (Opcode.STORE_REG, Opcode.LOAD_CONST, Opcode.LOAD_ATTR,
                           Opcode.LOAD_GLOBAL, Opcode.BINARY_OP, Opcode.UNARY_OP,
                           Opcode.COMPARE, Opcode.CALL, Opcode.PHI, Opcode.MATCH_BIND):
            if self.operands and isinstance(self.operands[0], Reg):
                defined.add(self.operands[0])
        return defined
    
    def regs_used(self) -> Set[Reg]:
        """Return set of registers used by this instruction."""
        used: Set[Reg] = set()
        start_idx = 1 if self.opcode in (Opcode.STORE_REG, Opcode.BINARY_OP,
                                          Opcode.UNARY_OP, Opcode.COMPARE) else 0
        for op in self.operands[start_idx:]:
            if isinstance(op, Reg):
                used.add(op)
            elif isinstance(op, (tuple, list)):
                for item in op:
                    if isinstance(item, Reg):
                        used.add(item)
        return used
    
    def __repr__(self) -> str:
        ops = ", ".join(repr(o) for o in self.operands)
        loc = f" @{self.source_line}" if self.source_line else ""
        return f"{self.opcode.name}({ops}){loc}"


@dataclass(slots=True)
class CodeBlock:
    """Basic block in abstract bytecode CFG."""
    block_id: int
    instructions: List[Instruction] = field(default_factory=list)
    successors: List[int] = field(default_factory=list)
    predecessors: List[int] = field(default_factory=list)
    
    def is_empty(self) -> bool:
        return len(self.instructions) == 0
    
    def terminator(self) -> Optional[Instruction]:
        if self.instructions:
            last = self.instructions[-1]
            if last.opcode in (Opcode.JUMP, Opcode.BRANCH, Opcode.RETURN):
                return last
        return None


@dataclass(slots=True)
class FunctionCode:
    """Abstract bytecode for a single function/checker."""
    name: str
    func_id: int
    blocks: Dict[int, CodeBlock] = field(default_factory=dict)
    entry_id: int = 0
    exit_ids: List[int] = field(default_factory=list)
    params: List[Reg] = field(default_factory=list)
    locals_: List[Reg] = field(default_factory=list)
    source_file: Optional[str] = None
    
    @property
    def entry_block(self) -> CodeBlock:
        return self.blocks[self.entry_id]
    
    def block_order(self) -> List[int]:
        """Return block IDs in reverse post-order (suitable for dataflow)."""
        visited: Set[int] = set()
        post_order: List[int] = []
        
        def dfs(bid: int) -> None:
            if bid in visited:
                return
            visited.add(bid)
            for succ in self.blocks[bid].successors:
                dfs(succ)
            post_order.append(bid)
        
        dfs(self.entry_id)
        return list(reversed(post_order))
    
    def dump(self) -> str:
        lines = [f"function {self.name}({', '.join(p.name for p in self.params)}):"]
        for bid in self.block_order():
            blk = self.blocks[bid]
            succs = ", ".join(str(s) for s in blk.successors)
            lines.append(f"  block {bid} -> [{succs}]:")
            for instr in blk.instructions:
                lines.append(f"    {instr}")
        return "\n".join(lines)


@dataclass(slots=True)
class AbstractProgram:
    """Complete abstract bytecode image for a translation unit."""
    functions: Dict[str, FunctionCode] = field(default_factory=dict)
    func_by_id: Dict[int, FunctionCode] = field(default_factory=dict)
    globals_: List[Instruction] = field(default_factory=list)
    source_file: Optional[str] = None
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def add_function(self, fc: FunctionCode) -> None:
        self.functions[fc.name] = fc
        self.func_by_id[fc.func_id] = fc
    
    def dump(self) -> str:
        lines = [f"# AbstractProgram: {self.source_file or '<unknown>'}"]
        if self.globals_:
            lines.append("globals:")
            for instr in self.globals_:
                lines.append(f"  {instr}")
        for fc in self.functions.values():
            lines.append("")
            lines.append(fc.dump())
        return "\n".join(lines)


# =============================================================================
# CASL AST Node Definitions (Placeholder - actual definitions in casl/ast.py)
# =============================================================================

class CaslNode(ABC):
    """Base class for all CASL AST nodes."""
    source_line: Optional[int] = None
    source_column: Optional[int] = None


class CaslType(Enum):
    """CASL type system."""
    VOID = auto()
    BOOL = auto()
    INT = auto()
    STRING = auto()
    TOKEN = auto()
    SCOPE = auto()
    FUNCTION = auto()
    VARIABLE = auto()
    EXPRESSION = auto()
    STATEMENT = auto()
    ANY = auto()


@dataclass
class CaslProperty(CaslNode):
    """Property specification node."""
    name: str
    pattern: str  # SAFETY, LIVENESS, etc.
    formula: 'CaslFormula'
    message: str
    severity: str = "warning"


@dataclass
class CaslFormula(CaslNode):
    """Temporal logic formula node."""
    operator: str  # AG, AF, EG, EF, AU, EU, G, F, X, U, R
    operands: List['CaslFormula']
    predicate: Optional['CaslPredicate'] = None


@dataclass
class CaslPredicate(CaslNode):
    """Atomic predicate in a formula."""
    name: str
    args: List['CaslExpr']


@dataclass
class CaslExpr(CaslNode):
    """CASL expression node."""
    pass


@dataclass
class CaslIdentifier(CaslExpr):
    """Identifier reference."""
    name: str


@dataclass
class CaslLiteral(CaslExpr):
    """Literal value."""
    value: Any
    type_: CaslType


@dataclass
class CaslBinaryOp(CaslExpr):
    """Binary operation."""
    operator: str
    left: CaslExpr
    right: CaslExpr


@dataclass
class CaslUnaryOp(CaslExpr):
    """Unary operation."""
    operator: str
    operand: CaslExpr


@dataclass
class CaslCall(CaslExpr):
    """Function/predicate call."""
    callee: str
    args: List[CaslExpr]


@dataclass
class CaslAttrAccess(CaslExpr):
    """Attribute access (e.g., token.str, var.type)."""
    object_: CaslExpr
    attribute: str


# CSQL-specific nodes
@dataclass
class CsqlQuery(CaslNode):
    """CSQL query root node."""
    name: str
    pattern: 'CsqlPattern'
    where_clause: Optional['CsqlExpr'] = None
    select_clause: Optional[List[str]] = None


@dataclass
class CsqlPattern(CaslNode):
    """CSQL pattern matching specification."""
    pass


@dataclass
class CsqlNodePattern(CsqlPattern):
    """Match a specific AST node type."""
    node_type: str
    bindings: Dict[str, str] = field(default_factory=dict)
    predicates: List['CsqlPredicate'] = field(default_factory=list)


@dataclass
class CsqlSequence(CsqlPattern):
    """Sequential pattern matching."""
    patterns: List[CsqlPattern]


@dataclass
class CsqlAlternative(CsqlPattern):
    """Alternative patterns (OR)."""
    patterns: List[CsqlPattern]


@dataclass
class CsqlOptional(CsqlPattern):
    """Optional pattern (?)."""
    pattern: CsqlPattern


@dataclass
class CsqlRepeat(CsqlPattern):
    """Repeated pattern (*, +)."""
    pattern: CsqlPattern
    min_count: int = 0
    max_count: Optional[int] = None


@dataclass
class CsqlExpr(CaslNode):
    """CSQL expression in where clause."""
    pass


@dataclass
class CsqlAnd(CsqlExpr):
    """Conjunction of predicates."""
    operands: List[CsqlExpr]


@dataclass
class CsqlOr(CsqlExpr):
    """Disjunction of predicates."""
    operands: List[CsqlExpr]


@dataclass
class CsqlNot(CsqlExpr):
    """Negation."""
    operand: CsqlExpr


@dataclass
class CsqlPredicate(CsqlExpr):
    """CSQL predicate (has_attr, is_type, etc.)."""
    name: str
    args: List[CaslExpr]


@dataclass
class CsqlComparison(CsqlExpr):
    """Comparison expression."""
    operator: str
    left: CaslExpr
    right: CaslExpr


# =============================================================================
# Code Generation Infrastructure
# =============================================================================

class CodeGenError(Exception):
    """Error during code generation."""
    def __init__(self, message: str, node: Optional[CaslNode] = None):
        self.node = node
        loc = ""
        if node and node.source_line:
            loc = f" at line {node.source_line}"
            if node.source_column:
                loc += f", column {node.source_column}"
        super().__init__(f"{message}{loc}")


@dataclass
class CodeGenContext:
    """Context for code generation pass."""
    # Current function being generated
    current_function: Optional[str] = None
    
    # Register allocation
    _reg_counter: Iterator[int] = field(default_factory=lambda: itertools.count(0))
    _named_regs: Dict[str, Reg] = field(default_factory=dict)
    
    # Block management
    _block_counter: Iterator[int] = field(default_factory=lambda: itertools.count(0))
    current_block_id: int = 0
    
    # Symbol table for variable bindings
    symbols: Dict[str, Reg] = field(default_factory=dict)
    
    # State machine state (for property compilation)
    states: Dict[str, int] = field(default_factory=dict)
    current_state: int = 0
    
    # Loop/control flow stack
    break_targets: List[int] = field(default_factory=list)
    continue_targets: List[int] = field(default_factory=list)
    
    def fresh_reg(self, prefix: str = "t") -> Reg:
        """Allocate a fresh temporary register."""
        idx = next(self._reg_counter)
        return Reg(f"{prefix}{idx}")
    
    def named_reg(self, name: str) -> Reg:
        """Get or create a named register."""
        if name not in self._named_regs:
            self._named_regs[name] = Reg(name)
        return self._named_regs[name]
    
    def fresh_block_id(self) -> int:
        """Allocate a fresh block ID."""
        return next(self._block_counter)
    
    def bind_symbol(self, name: str, reg: Reg) -> None:
        """Bind a symbol to a register."""
        self.symbols[name] = reg
    
    def lookup_symbol(self, name: str) -> Optional[Reg]:
        """Look up a symbol binding."""
        return self.symbols.get(name)


class InstructionEmitter:
    """
    Bytecode instruction emitter following InstructionBuilder patterns.
    
    This class mirrors the InstructionBuilder API (cppcheckdata-shims-source-code.md
    lines 11656-11864) for compatibility with the existing infrastructure.
    """
    
    def __init__(self, ctx: CodeGenContext):
        self.ctx = ctx
        self.instructions: List[Instruction] = []
    
    def _loc(self, node: Optional[CaslNode]) -> Dict[str, Optional[int]]:
        """Extract source location from node."""
        if node:
            return {"source_line": node.source_line, "source_column": node.source_column}
        return {"source_line": None, "source_column": None}
    
    # -------------------------------------------------------------------------
    # Data movement instructions
    # -------------------------------------------------------------------------
    
    def load_const(self, dest: Reg, value: Any, node: Optional[CaslNode] = None) -> 'InstructionEmitter':
        """Load a constant value into a register."""
        self.instructions.append(Instruction(
            Opcode.LOAD_CONST, (dest, value), **self._loc(node)
        ))
        return self
    
    def load_reg(self, dest: Reg, src: Reg, node: Optional[CaslNode] = None) -> 'InstructionEmitter':
        """Copy register value."""
        self.instructions.append(Instruction(
            Opcode.LOAD_REG, (dest, src), **self._loc(node)
        ))
        return self
    
    def store_reg(self, dest: Reg, src: Reg, node: Optional[CaslNode] = None) -> 'InstructionEmitter':
        """Store value into register."""
        self.instructions.append(Instruction(
            Opcode.STORE_REG, (dest, src), **self._loc(node)
        ))
        return self
    
    def load_attr(self, dest: Reg, obj: Reg, attr: str, node: Optional[CaslNode] = None) -> 'InstructionEmitter':
        """Load attribute from object."""
        self.instructions.append(Instruction(
            Opcode.LOAD_ATTR, (dest, obj, attr), **self._loc(node)
        ))
        return self
    
    def load_global(self, dest: Reg, name: str, node: Optional[CaslNode] = None) -> 'InstructionEmitter':
        """Load global variable."""
        self.instructions.append(Instruction(
            Opcode.LOAD_GLOBAL, (dest, name), **self._loc(node)
        ))
        return self
    
    # -------------------------------------------------------------------------
    # Arithmetic and logic instructions
    # -------------------------------------------------------------------------
    
    def binary_op(self, dest: Reg, op: str, left: Reg, right: Reg,
                  node: Optional[CaslNode] = None) -> 'InstructionEmitter':
        """Emit binary operation."""
        self.instructions.append(Instruction(
            Opcode.BINARY_OP, (dest, op, left, right), **self._loc(node)
        ))
        return self
    
    def unary_op(self, dest: Reg, op: str, operand: Reg,
                 node: Optional[CaslNode] = None) -> 'InstructionEmitter':
        """Emit unary operation."""
        self.instructions.append(Instruction(
            Opcode.UNARY_OP, (dest, op, operand), **self._loc(node)
        ))
        return self
    
    def compare(self, dest: Reg, op: str, left: Reg, right: Reg,
                node: Optional[CaslNode] = None) -> 'InstructionEmitter':
        """Emit comparison operation."""
        self.instructions.append(Instruction(
            Opcode.COMPARE, (dest, op, left, right), **self._loc(node)
        ))
        return self
    
    # -------------------------------------------------------------------------
    # Control flow instructions
    # -------------------------------------------------------------------------
    
    def jump(self, target: int, node: Optional[CaslNode] = None) -> 'InstructionEmitter':
        """Unconditional jump to block."""
        self.instructions.append(Instruction(
            Opcode.JUMP, (BlockRef(target),), **self._loc(node)
        ))
        return self
    
    def branch(self, cond: Reg, true_target: int, false_target: int,
               node: Optional[CaslNode] = None) -> 'InstructionEmitter':
        """Conditional branch."""
        self.instructions.append(Instruction(
            Opcode.BRANCH, (cond, BlockRef(true_target), BlockRef(false_target)), **self._loc(node)
        ))
        return self
    
    def call(self, dest: Reg, callee: str, args: List[Reg],
             node: Optional[CaslNode] = None) -> 'InstructionEmitter':
        """Function call."""
        self.instructions.append(Instruction(
            Opcode.CALL, (dest, callee, tuple(args)), **self._loc(node)
        ))
        return self
    
    def return_(self, value: Optional[Reg] = None,
                node: Optional[CaslNode] = None) -> 'InstructionEmitter':
        """Return from function."""
        operands = (value,) if value else ()
        self.instructions.append(Instruction(
            Opcode.RETURN, operands, **self._loc(node)
        ))
        return self
    
    # -------------------------------------------------------------------------
    # Event and observation instructions (CASL-specific)
    # -------------------------------------------------------------------------
    
    def event(self, event_id: str, params: Optional[Tuple[Any, ...]] = None,
              node: Optional[CaslNode] = None) -> 'InstructionEmitter':
        """
        Emit an event for observation.
        
        Citation: cppcheckdata-shims-source-code.md lines 11760-11764
        """
        self.instructions.append(Instruction(
            Opcode.EVENT, (EventRef(event_id, params or ()),), **self._loc(node)
        ))
        return self
    
    def observe(self, observer_id: str, regs: Optional[List[Reg]] = None,
                node: Optional[CaslNode] = None) -> 'InstructionEmitter':
        """
        Register an observer.
        
        Citation: cppcheckdata-shims-source-code.md lines 11766-11771
        """
        self.instructions.append(Instruction(
            Opcode.OBSERVE, (ObserverRef(observer_id, tuple(regs or ())),), **self._loc(node)
        ))
        return self
    
    def enter_scope(self, scope_name: str, node: Optional[CaslNode] = None) -> 'InstructionEmitter':
        """Enter a named scope."""
        self.instructions.append(Instruction(
            Opcode.ENTER_SCOPE, (scope_name,), **self._loc(node)
        ))
        return self
    
    def exit_scope(self, scope_name: str, node: Optional[CaslNode] = None) -> 'InstructionEmitter':
        """Exit a named scope."""
        self.instructions.append(Instruction(
            Opcode.EXIT_SCOPE, (scope_name,), **self._loc(node)
        ))
        return self
    
    # -------------------------------------------------------------------------
    # State machine instructions
    # -------------------------------------------------------------------------
    
    def state_transition(self, from_state: int, to_state: int, event: str,
                         node: Optional[CaslNode] = None) -> 'InstructionEmitter':
        """Transition state machine."""
        self.instructions.append(Instruction(
            Opcode.STATE_TRANSITION, (from_state, to_state, event), **self._loc(node)
        ))
        return self
    
    def state_check(self, dest: Reg, state: int,
                    node: Optional[CaslNode] = None) -> 'InstructionEmitter':
        """Check if in specific state."""
        self.instructions.append(Instruction(
            Opcode.STATE_CHECK, (dest, state), **self._loc(node)
        ))
        return self
    
    def emit_diagnostic(self, error_id: str, message: str, severity: str,
                        location_reg: Reg, node: Optional[CaslNode] = None) -> 'InstructionEmitter':
        """Emit a diagnostic (for checker integration)."""
        self.instructions.append(Instruction(
            Opcode.EMIT_DIAGNOSTIC, (error_id, message, severity, location_reg), **self._loc(node)
        ))
        return self
    
    # -------------------------------------------------------------------------
    # Query/matching instructions
    # -------------------------------------------------------------------------
    
    def match_start(self, query_id: str, node: Optional[CaslNode] = None) -> 'InstructionEmitter':
        """Start a pattern matching sequence."""
        self.instructions.append(Instruction(
            Opcode.MATCH_START, (query_id,), **self._loc(node)
        ))
        return self
    
    def match_bind(self, dest: Reg, binding_name: str,
                   node: Optional[CaslNode] = None) -> 'InstructionEmitter':
        """Bind matched element to register."""
        self.instructions.append(Instruction(
            Opcode.MATCH_BIND, (dest, binding_name), **self._loc(node)
        ))
        return self
    
    def match_filter(self, cond: Reg, node: Optional[CaslNode] = None) -> 'InstructionEmitter':
        """Filter match by condition."""
        self.instructions.append(Instruction(
            Opcode.MATCH_FILTER, (cond,), **self._loc(node)
        ))
        return self
    
    def match_yield(self, bindings: Dict[str, Reg],
                    node: Optional[CaslNode] = None) -> 'InstructionEmitter':
        """Yield a successful match."""
        self.instructions.append(Instruction(
            Opcode.MATCH_YIELD, (tuple(bindings.items()),), **self._loc(node)
        ))
        return self
    
    def nop(self, node: Optional[CaslNode] = None) -> 'InstructionEmitter':
        """No operation."""
        self.instructions.append(Instruction(
            Opcode.NOP, (), **self._loc(node)
        ))
        return self
    
    def phi(self, dest: Reg, sources: List[Tuple[int, Reg]],
            node: Optional[CaslNode] = None) -> 'InstructionEmitter':
        """PHI node for SSA form."""
        self.instructions.append(Instruction(
            Opcode.PHI, (dest, tuple(sources)), **self._loc(node)
        ))
        return self
    
    # -------------------------------------------------------------------------
    # Block building (mirrors InstructionBuilder.build_block)
    # -------------------------------------------------------------------------
    
    def build_block(self, block_id: Optional[int] = None, **kwargs: Any) -> CodeBlock:
        """
        Build a CodeBlock from accumulated instructions.
        
        Citation: cppcheckdata-shims-source-code.md lines 11821-11825
        """
        if block_id is None:
            block_id = self.ctx.fresh_block_id()
        
        block = CodeBlock(
            block_id=block_id,
            instructions=list(self.instructions),
            **kwargs
        )
        self.instructions.clear()
        return block
    
    def clear(self) -> None:
        """Clear accumulated instructions."""
        self.instructions.clear()


class FunctionBuilder:
    """
    Builder for constructing FunctionCode from blocks.
    
    Mirrors InstructionBuilder.build_function (lines 11827-11863)
    """
    
    def __init__(self, name: str, func_id: int = 0):
        self.name = name
        self.func_id = func_id
        self.blocks: Dict[int, CodeBlock] = {}
        self.entry_id: int = 0
        self.exit_ids: List[int] = []
        self.params: List[Reg] = []
        self.source_file: Optional[str] = None
    
    def add_block(self, block: CodeBlock) -> 'FunctionBuilder':
        """Add a block to the function."""
        self.blocks[block.block_id] = block
        return self
    
    def set_entry(self, block_id: int) -> 'FunctionBuilder':
        """Set entry block."""
        self.entry_id = block_id
        return self
    
    def add_exit(self, block_id: int) -> 'FunctionBuilder':
        """Add exit block."""
        if block_id not in self.exit_ids:
            self.exit_ids.append(block_id)
        return self
    
    def add_param(self, param: Union[str, Reg]) -> 'FunctionBuilder':
        """Add parameter."""
        if isinstance(param, str):
            param = Reg(param)
        self.params.append(param)
        return self
    
    def build(self) -> FunctionCode:
        """
        Build FunctionCode with CFG edge wiring.
        
        Citation: cppcheckdata-shims-source-code.md lines 11835-11863
        """
        fc = FunctionCode(
            name=self.name,
            func_id=self.func_id,
            blocks=self.blocks,
            entry_id=self.entry_id,
            exit_ids=self.exit_ids,
            params=self.params,
            source_file=self.source_file,
        )
        
        # Wire successors and predecessors from terminators
        for block in self.blocks.values():
            for instr in block.instructions:
                if instr.opcode == Opcode.JUMP and instr.operands:
                    target_ref = instr.operands[0]
                    if isinstance(target_ref, BlockRef):
                        target = target_ref.block_id
                        if target not in block.successors:
                            block.successors.append(target)
                        if target in self.blocks:
                            if block.block_id not in self.blocks[target].predecessors:
                                self.blocks[target].predecessors.append(block.block_id)
                
                elif instr.opcode == Opcode.BRANCH and len(instr.operands) >= 3:
                    for ref in instr.operands[1:3]:
                        if isinstance(ref, BlockRef):
                            target = ref.block_id
                            if target not in block.successors:
                                block.successors.append(target)
                            if target in self.blocks:
                                if block.block_id not in self.blocks[target].predecessors:
                                    self.blocks[target].predecessors.append(block.block_id)
        
        # Infer locals from register usage
        all_regs: Set[Reg] = set()
        for block in self.blocks.values():
            for instr in block.instructions:
                all_regs |= instr.regs_defined() | instr.regs_used()
        
        fc.locals_ = sorted(all_regs, key=lambda r: r.name)
        
        return fc


# =============================================================================
# Code Generator Visitors
# =============================================================================

class CaslCodeGenVisitor(ABC):
    """Base visitor for CASL code generation."""
    
    @abstractmethod
    def visit(self, node: CaslNode, ctx: CodeGenContext, emitter: InstructionEmitter) -> Any:
        """Visit a node and generate code."""
        pass


class ExprCodeGen(CaslCodeGenVisitor):
    """Code generator for CASL expressions."""
    
    def visit(self, node: CaslNode, ctx: CodeGenContext, emitter: InstructionEmitter) -> Reg:
        """Generate code for an expression, returning the result register."""
        if isinstance(node, CaslIdentifier):
            return self.visit_identifier(node, ctx, emitter)
        elif isinstance(node, CaslLiteral):
            return self.visit_literal(node, ctx, emitter)
        elif isinstance(node, CaslBinaryOp):
            return self.visit_binary_op(node, ctx, emitter)
        elif isinstance(node, CaslUnaryOp):
            return self.visit_unary_op(node, ctx, emitter)
        elif isinstance(node, CaslCall):
            return self.visit_call(node, ctx, emitter)
        elif isinstance(node, CaslAttrAccess):
            return self.visit_attr_access(node, ctx, emitter)
        else:
            raise CodeGenError(f"Unknown expression type: {type(node).__name__}", node)
    
    def visit_identifier(self, node: CaslIdentifier, ctx: CodeGenContext,
                         emitter: InstructionEmitter) -> Reg:
        """Generate code for identifier reference."""
        reg = ctx.lookup_symbol(node.name)
        if reg is None:
            # Try as global
            dest = ctx.fresh_reg("g")
            emitter.load_global(dest, node.name, node)
            return dest
        return reg
    
    def visit_literal(self, node: CaslLiteral, ctx: CodeGenContext,
                      emitter: InstructionEmitter) -> Reg:
        """Generate code for literal value."""
        dest = ctx.fresh_reg("c")
        emitter.load_const(dest, node.value, node)
        return dest
    
    def visit_binary_op(self, node: CaslBinaryOp, ctx: CodeGenContext,
                        emitter: InstructionEmitter) -> Reg:
        """Generate code for binary operation."""
        left_reg = self.visit(node.left, ctx, emitter)
        right_reg = self.visit(node.right, ctx, emitter)
        dest = ctx.fresh_reg("t")
        
        # Map comparison operators
        if node.operator in ("==", "!=", "<", "<=", ">", ">="):
            emitter.compare(dest, node.operator, left_reg, right_reg, node)
        else:
            emitter.binary_op(dest, node.operator, left_reg, right_reg, node)
        
        return dest
    
    def visit_unary_op(self, node: CaslUnaryOp, ctx: CodeGenContext,
                       emitter: InstructionEmitter) -> Reg:
        """Generate code for unary operation."""
        operand_reg = self.visit(node.operand, ctx, emitter)
        dest = ctx.fresh_reg("t")
        emitter.unary_op(dest, node.operator, operand_reg, node)
        return dest
    
    def visit_call(self, node: CaslCall, ctx: CodeGenContext,
                   emitter: InstructionEmitter) -> Reg:
        """Generate code for function call."""
        arg_regs = [self.visit(arg, ctx, emitter) for arg in node.args]
        dest = ctx.fresh_reg("r")
        emitter.call(dest, node.callee, arg_regs, node)
        return dest
    
    def visit_attr_access(self, node: CaslAttrAccess, ctx: CodeGenContext,
                          emitter: InstructionEmitter) -> Reg:
        """Generate code for attribute access."""
        obj_reg = self.visit(node.object_, ctx, emitter)
        dest = ctx.fresh_reg("a")
        emitter.load_attr(dest, obj_reg, node.attribute, node)
        return dest


class PropertyCodeGen:
    """
    Code generator for CASL property specifications.
    
    Compiles temporal logic properties into state machine monitors
    that integrate with the Checker infrastructure.
    """
    
    def __init__(self):
        self.expr_gen = ExprCodeGen()
        self._func_id_counter = itertools.count(1)
    
    def compile_property(self, prop: CaslProperty, ctx: CodeGenContext) -> FunctionCode:
        """
        Compile a property into monitor bytecode.
        
        The generated FunctionCode implements the state machine for
        monitoring the property at runtime.
        """
        builder = FunctionBuilder(
            name=f"__monitor_{prop.name}",
            func_id=next(self._func_id_counter)
        )
        
        # State machine compilation based on pattern type
        if prop.pattern == "SAFETY":
            return self._compile_safety_property(prop, ctx, builder)
        elif prop.pattern == "LIVENESS":
            return self._compile_liveness_property(prop, ctx, builder)
        elif prop.pattern == "RESPONSE":
            return self._compile_response_property(prop, ctx, builder)
        elif prop.pattern == "PRECEDENCE":
            return self._compile_precedence_property(prop, ctx, builder)
        else:
            # Default: compile as general temporal formula
            return self._compile_general_property(prop, ctx, builder)
    
    def _compile_safety_property(self, prop: CaslProperty, ctx: CodeGenContext,
                                  builder: FunctionBuilder) -> FunctionCode:
        """
        Compile AG(invariant) safety property.
        
        State machine:
            S0 (init) --[!invariant]--> S1 (error)
            S0 (init) --[invariant]--> S0 (init)
        """
        emitter = InstructionEmitter(ctx)
        
        # Entry block: check invariant
        entry_id = ctx.fresh_block_id()
        ok_id = ctx.fresh_block_id()
        error_id = ctx.fresh_block_id()
        exit_id = ctx.fresh_block_id()
        
        # Add parameter for event/token being checked
        builder.add_param("event")
        event_reg = ctx.named_reg("event")
        
        # Entry: evaluate invariant predicate
        emitter.enter_scope("safety_check", prop)
        cond_reg = self._compile_formula(prop.formula, ctx, emitter, event_reg)
        emitter.branch(cond_reg, ok_id, error_id, prop)
        entry_block = emitter.build_block(entry_id)
        builder.add_block(entry_block)
        
        # OK block: property holds
        emitter.event("property_ok", (prop.name,))
        emitter.jump(exit_id)
        ok_block = emitter.build_block(ok_id)
        builder.add_block(ok_block)
        
        # Error block: emit diagnostic
        loc_reg = ctx.fresh_reg("loc")
        emitter.load_attr(loc_reg, event_reg, "location", prop)
        emitter.emit_diagnostic(
            f"{prop.name}_violation",
            prop.message,
            prop.severity,
            loc_reg,
            prop
        )
        emitter.event("property_violated", (prop.name,))
        emitter.jump(exit_id)
        error_block = emitter.build_block(error_id)
        builder.add_block(error_block)
        
        # Exit block
        emitter.exit_scope("safety_check")
        emitter.return_(None, prop)
        exit_block = emitter.build_block(exit_id)
        builder.add_block(exit_block)
        
        builder.set_entry(entry_id)
        builder.add_exit(exit_id)
        
        return builder.build()
    
    def _compile_liveness_property(self, prop: CaslProperty, ctx: CodeGenContext,
                                    builder: FunctionBuilder) -> FunctionCode:
        """
        Compile AF(goal) liveness property.
        
        State machine:
            S0 (waiting) --[goal]--> S1 (satisfied)
            S0 (waiting) --[!goal]--> S0 (waiting)
            End-of-trace in S0 --> error
        """
        emitter = InstructionEmitter(ctx)
        
        # States
        STATE_WAITING = 0
        STATE_SATISFIED = 1
        
        entry_id = ctx.fresh_block_id()
        check_id = ctx.fresh_block_id()
        satisfied_id = ctx.fresh_block_id()
        still_waiting_id = ctx.fresh_block_id()
        exit_id = ctx.fresh_block_id()
        
        builder.add_param("event")
        builder.add_param("is_end_of_trace")
        event_reg = ctx.named_reg("event")
        eot_reg = ctx.named_reg("is_end_of_trace")
        
        # Entry: load current state
        state_reg = ctx.fresh_reg("state")
        emitter.load_global(state_reg, f"__state_{prop.name}", prop)
        emitter.jump(check_id)
        entry_block = emitter.build_block(entry_id)
        builder.add_block(entry_block)
        
        # Check block: evaluate goal
        cond_reg = self._compile_formula(prop.formula, ctx, emitter, event_reg)
        emitter.branch(cond_reg, satisfied_id, still_waiting_id, prop)
        check_block = emitter.build_block(check_id)
        builder.add_block(check_block)
        
        # Satisfied: transition to satisfied state
        emitter.state_transition(STATE_WAITING, STATE_SATISFIED, "goal_reached")
        emitter.event("liveness_satisfied", (prop.name,))
        emitter.jump(exit_id)
        satisfied_block = emitter.build_block(satisfied_id)
        builder.add_block(satisfied_block)
        
        # Still waiting: check for end-of-trace error
        eot_error_id = ctx.fresh_block_id()
        emitter.branch(eot_reg, eot_error_id, exit_id, prop)
        still_waiting_block = emitter.build_block(still_waiting_id)
        builder.add_block(still_waiting_block)
        
        # EOT error: liveness violated
        loc_reg = ctx.fresh_reg("loc")
        emitter.load_attr(loc_reg, event_reg, "location", prop)
        emitter.emit_diagnostic(
            f"{prop.name}_liveness_violation",
            f"Liveness property '{prop.name}' never satisfied: {prop.message}",
            "error",
            loc_reg,
            prop
        )
        emitter.jump(exit_id)
        eot_error_block = emitter.build_block(eot_error_id)
        builder.add_block(eot_error_block)
        
        # Exit
        emitter.return_(None)
        exit_block = emitter.build_block(exit_id)
        builder.add_block(exit_block)
        
        builder.set_entry(entry_id)
        builder.add_exit(exit_id)
        
        return builder.build()
    
    def _compile_response_property(self, prop: CaslProperty, ctx: CodeGenContext,
                                    builder: FunctionBuilder) -> FunctionCode:
        """
        Compile AG(trigger => AF(response)) response property.
        
        State machine:
            S0 (idle) --[trigger]--> S1 (obligated)
            S0 (idle) --[!trigger]--> S0 (idle)
            S1 (obligated) --[response]--> S0 (idle)
            S1 (obligated) --[!response]--> S1 (obligated)
            End-of-trace in S1 --> error
        """
        emitter = InstructionEmitter(ctx)
        
        STATE_IDLE = 0
        STATE_OBLIGATED = 1
        
        entry_id = ctx.fresh_block_id()
        check_state_id = ctx.fresh_block_id()
        idle_check_id = ctx.fresh_block_id()
        obligated_check_id = ctx.fresh_block_id()
        become_obligated_id = ctx.fresh_block_id()
        response_met_id = ctx.fresh_block_id()
        eot_check_id = ctx.fresh_block_id()
        eot_error_id = ctx.fresh_block_id()
        exit_id = ctx.fresh_block_id()
        
        builder.add_param("event")
        builder.add_param("is_end_of_trace")
        event_reg = ctx.named_reg("event")
        eot_reg = ctx.named_reg("is_end_of_trace")
        
        # Entry: load state
        state_reg = ctx.fresh_reg("state")
        emitter.load_global(state_reg, f"__state_{prop.name}", prop)
        emitter.jump(check_state_id)
        builder.add_block(emitter.build_block(entry_id))
        
        # Check state dispatch
        idle_cond = ctx.fresh_reg("idle_cond")
        emitter.state_check(idle_cond, STATE_IDLE, prop)
        emitter.branch(idle_cond, idle_check_id, obligated_check_id, prop)
        builder.add_block(emitter.build_block(check_state_id))
        
        # Idle state: check trigger
        # Assume formula has two operands: trigger and response
        if (isinstance(prop.formula, CaslFormula) and 
            len(prop.formula.operands) >= 2):
            trigger = prop.formula.operands[0]
            response = prop.formula.operands[1]
        else:
            # Fallback: use formula as both
            trigger = prop.formula
            response = prop.formula
        
        trigger_cond = self._compile_formula(trigger, ctx, emitter, event_reg)
        emitter.branch(trigger_cond, become_obligated_id, exit_id, prop)
        builder.add_block(emitter.build_block(idle_check_id))
        
        # Become obligated
        emitter.state_transition(STATE_IDLE, STATE_OBLIGATED, "trigger_fired")
        emitter.event("response_obligation_started", (prop.name,))
        emitter.jump(exit_id)
        builder.add_block(emitter.build_block(become_obligated_id))
        
        # Obligated state: check response
        response_cond = self._compile_formula(response, ctx, emitter, event_reg)
        emitter.branch(response_cond, response_met_id, eot_check_id, prop)
        builder.add_block(emitter.build_block(obligated_check_id))
        
        # Response met: back to idle
        emitter.state_transition(STATE_OBLIGATED, STATE_IDLE, "response_met")
        emitter.event("response_obligation_fulfilled", (prop.name,))
        emitter.jump(exit_id)
        builder.add_block(emitter.build_block(response_met_id))
        
        # Check for EOT while obligated
        emitter.branch(eot_reg, eot_error_id, exit_id, prop)
        builder.add_block(emitter.build_block(eot_check_id))
        
        # EOT error
        loc_reg = ctx.fresh_reg("loc")
        emitter.load_attr(loc_reg, event_reg, "location", prop)
        emitter.emit_diagnostic(
            f"{prop.name}_response_violation",
            f"Response property '{prop.name}' not fulfilled: {prop.message}",
            "error",
            loc_reg,
            prop
        )
        emitter.jump(exit_id)
        builder.add_block(emitter.build_block(eot_error_id))
        
        # Exit
        emitter.return_(None)
        builder.add_block(emitter.build_block(exit_id))
        
        builder.set_entry(entry_id)
        builder.add_exit(exit_id)
        
        return builder.build()
    
    def _compile_precedence_property(self, prop: CaslProperty, ctx: CodeGenContext,
                                      builder: FunctionBuilder) -> FunctionCode:
        """
        Compile !event1 W event2 (event1 must not happen before event2).
        
        State machine:
            S0 (watching) --[event2]--> S1 (satisfied, absorbing)
            S0 (watching) --[event1]--> S2 (violated)
            S0 (watching) --[other]--> S0 (watching)
        """
        emitter = InstructionEmitter(ctx)
        
        STATE_WATCHING = 0
        STATE_SATISFIED = 1
        STATE_VIOLATED = 2
        
        entry_id = ctx.fresh_block_id()
        check_e2_id = ctx.fresh_block_id()
        check_e1_id = ctx.fresh_block_id()
        satisfied_id = ctx.fresh_block_id()
        violated_id = ctx.fresh_block_id()
        exit_id = ctx.fresh_block_id()
        
        builder.add_param("event")
        event_reg = ctx.named_reg("event")
        
        # Entry
        state_reg = ctx.fresh_reg("state")
        emitter.load_global(state_reg, f"__state_{prop.name}", prop)
        
        # Check if already in terminal state
        satisfied_cond = ctx.fresh_reg("sat_cond")
        emitter.state_check(satisfied_cond, STATE_SATISFIED, prop)
        emitter.branch(satisfied_cond, exit_id, check_e2_id, prop)
        builder.add_block(emitter.build_block(entry_id))
        
        # Check event2 (the enabling event)
        if (isinstance(prop.formula, CaslFormula) and 
            len(prop.formula.operands) >= 2):
            event2_formula = prop.formula.operands[1]
            event1_formula = prop.formula.operands[0]
        else:
            event2_formula = prop.formula
            event1_formula = prop.formula
        
        e2_cond = self._compile_formula(event2_formula, ctx, emitter, event_reg)
        emitter.branch(e2_cond, satisfied_id, check_e1_id, prop)
        builder.add_block(emitter.build_block(check_e2_id))
        
        # Check event1 (the forbidden event)
        e1_cond = self._compile_formula(event1_formula, ctx, emitter, event_reg)
        emitter.branch(e1_cond, violated_id, exit_id, prop)
        builder.add_block(emitter.build_block(check_e1_id))
        
        # Satisfied
        emitter.state_transition(STATE_WATCHING, STATE_SATISFIED, "precedence_enabled")
        emitter.event("precedence_satisfied", (prop.name,))
        emitter.jump(exit_id)
        builder.add_block(emitter.build_block(satisfied_id))
        
        # Violated
        emitter.state_transition(STATE_WATCHING, STATE_VIOLATED, "precedence_violated")
        loc_reg = ctx.fresh_reg("loc")
        emitter.load_attr(loc_reg, event_reg, "location", prop)
        emitter.emit_diagnostic(
            f"{prop.name}_precedence_violation",
            f"Precedence property '{prop.name}' violated: {prop.message}",
            prop.severity,
            loc_reg,
            prop
        )
        emitter.jump(exit_id)
        builder.add_block(emitter.build_block(violated_id))
        
        # Exit
        emitter.return_(None)
        builder.add_block(emitter.build_block(exit_id))
        
        builder.set_entry(entry_id)
        builder.add_exit(exit_id)
        
        return builder.build()
    
    def _compile_general_property(self, prop: CaslProperty, ctx: CodeGenContext,
                                   builder: FunctionBuilder) -> FunctionCode:
        """Compile arbitrary temporal formula."""
        emitter = InstructionEmitter(ctx)
        
        entry_id = ctx.fresh_block_id()
        exit_id = ctx.fresh_block_id()
        
        builder.add_param("event")
        event_reg = ctx.named_reg("event")
        
        # Evaluate formula
        result_reg = self._compile_formula(prop.formula, ctx, emitter, event_reg)
        
        # Check result and potentially emit diagnostic
        ok_id = ctx.fresh_block_id()
        error_id = ctx.fresh_block_id()
        
        emitter.branch(result_reg, ok_id, error_id, prop)
        builder.add_block(emitter.build_block(entry_id))
        
        # OK
        emitter.event("property_holds", (prop.name,))
        emitter.jump(exit_id)
        builder.add_block(emitter.build_block(ok_id))
        
        # Error
        loc_reg = ctx.fresh_reg("loc")
        emitter.load_attr(loc_reg, event_reg, "location", prop)
        emitter.emit_diagnostic(prop.name, prop.message, prop.severity, loc_reg, prop)
        emitter.jump(exit_id)
        builder.add_block(emitter.build_block(error_id))
        
        # Exit
        emitter.return_(None)
        builder.add_block(emitter.build_block(exit_id))
        
        builder.set_entry(entry_id)
        builder.add_exit(exit_id)
        
        return builder.build()
    
    def _compile_formula(self, formula: CaslFormula, ctx: CodeGenContext,
                         emitter: InstructionEmitter, event_reg: Reg) -> Reg:
        """Compile a temporal formula into condition evaluation code."""
        if formula.predicate:
            # Atomic predicate
            return self._compile_predicate(formula.predicate, ctx, emitter, event_reg)
        
        op = formula.operator.upper()
        
        if op in ("AG", "G"):
            # Invariant: evaluate inner formula
            if formula.operands:
                return self._compile_formula(formula.operands[0], ctx, emitter, event_reg)
            else:
                # Empty formula is true
                result = ctx.fresh_reg("true")
                emitter.load_const(result, True, formula)
                return result
        
        elif op in ("AF", "F"):
            # Eventually: for single-step, evaluate now
            if formula.operands:
                return self._compile_formula(formula.operands[0], ctx, emitter, event_reg)
            else:
                result = ctx.fresh_reg("true")
                emitter.load_const(result, True, formula)
                return result
        
        elif op == "NOT":
            if formula.operands:
                inner = self._compile_formula(formula.operands[0], ctx, emitter, event_reg)
                result = ctx.fresh_reg("not")
                emitter.unary_op(result, "not", inner, formula)
                return result
            else:
                result = ctx.fresh_reg("false")
                emitter.load_const(result, False, formula)
                return result
        
        elif op == "AND":
            if not formula.operands:
                result = ctx.fresh_reg("true")
                emitter.load_const(result, True, formula)
                return result
            
            result = self._compile_formula(formula.operands[0], ctx, emitter, event_reg)
            for operand in formula.operands[1:]:
                next_result = self._compile_formula(operand, ctx, emitter, event_reg)
                new_result = ctx.fresh_reg("and")
                emitter.binary_op(new_result, "and", result, next_result, formula)
                result = new_result
            return result
        
        elif op == "OR":
            if not formula.operands:
                result = ctx.fresh_reg("false")
                emitter.load_const(result, False, formula)
                return result
            
            result = self._compile_formula(formula.operands[0], ctx, emitter, event_reg)
            for operand in formula.operands[1:]:
                next_result = self._compile_formula(operand, ctx, emitter, event_reg)
                new_result = ctx.fresh_reg("or")
                emitter.binary_op(new_result, "or", result, next_result, formula)
                result = new_result
            return result
        
        elif op == "IMPLIES":
            if len(formula.operands) >= 2:
                left = self._compile_formula(formula.operands[0], ctx, emitter, event_reg)
                right = self._compile_formula(formula.operands[1], ctx, emitter, event_reg)
                # p => q ≡ !p || q
                not_left = ctx.fresh_reg("notl")
                emitter.unary_op(not_left, "not", left, formula)
                result = ctx.fresh_reg("impl")
                emitter.binary_op(result, "or", not_left, right, formula)
                return result
            else:
                result = ctx.fresh_reg("true")
                emitter.load_const(result, True, formula)
                return result
        
        else:
            raise CodeGenError(f"Unknown temporal operator: {op}", formula)
    
    def _compile_predicate(self, pred: CaslPredicate, ctx: CodeGenContext,
                           emitter: InstructionEmitter, event_reg: Reg) -> Reg:
        """Compile an atomic predicate."""
        # Generate code for predicate arguments
        arg_regs: List[Reg] = []
        for arg in pred.args:
            arg_reg = self.expr_gen.visit(arg, ctx, emitter)
            arg_regs.append(arg_reg)
        
        # Call the predicate function
        result = ctx.fresh_reg("pred")
        emitter.call(result, f"__pred_{pred.name}", [event_reg] + arg_regs, pred)
        return result


class CsqlCodeGen:
    """
    Code generator for CSQL (Code Structural Query Language) queries.
    
    Compiles CSQL patterns into matching bytecode that iterates over
    AST nodes and yields matches.
    """
    
    def __init__(self):
        self.expr_gen = ExprCodeGen()
        self._func_id_counter = itertools.count(1000)  # Separate namespace
    
    def compile_query(self, query: CsqlQuery, ctx: CodeGenContext) -> FunctionCode:
        """Compile a CSQL query into matcher bytecode."""
        builder = FunctionBuilder(
            name=f"__query_{query.name}",
            func_id=next(self._func_id_counter)
        )
        
        emitter = InstructionEmitter(ctx)
        
        entry_id = ctx.fresh_block_id()
        pattern_id = ctx.fresh_block_id()
        filter_id = ctx.fresh_block_id()
        yield_id = ctx.fresh_block_id()
        next_id = ctx.fresh_block_id()
        exit_id = ctx.fresh_block_id()
        
        # Parameters: AST root to search
        builder.add_param("ast_root")
        root_reg = ctx.named_reg("ast_root")
        
        # Entry: start match
        emitter.match_start(query.name, query)
        emitter.event("query_started", (query.name,))
        emitter.jump(pattern_id)
        builder.add_block(emitter.build_block(entry_id))
        
        # Pattern matching: compile the pattern
        bindings: Dict[str, Reg] = {}
        match_result = self._compile_pattern(query.pattern, ctx, emitter, root_reg, bindings)
        emitter.branch(match_result, filter_id, next_id, query.pattern)
        builder.add_block(emitter.build_block(pattern_id))
        
        # Filter: apply where clause if present
        if query.where_clause:
            filter_result = self._compile_where(query.where_clause, ctx, emitter, bindings)
            emitter.branch(filter_result, yield_id, next_id, query.where_clause)
        else:
            emitter.jump(yield_id)
        builder.add_block(emitter.build_block(filter_id))
        
        # Yield: emit successful match
        # Select specific bindings if select_clause provided
        if query.select_clause:
            selected = {k: v for k, v in bindings.items() if k in query.select_clause}
        else:
            selected = bindings
        emitter.match_yield(selected, query)
        emitter.event("query_match", (query.name, tuple(selected.keys())))
        emitter.jump(next_id)
        builder.add_block(emitter.build_block(yield_id))
        
        # Next: continue iteration (simplified - actual impl needs iterator state)
        # In real implementation, this would manage cursor/iterator
        emitter.jump(exit_id)
        builder.add_block(emitter.build_block(next_id))
        
        # Exit
        emitter.event("query_finished", (query.name,))
        emitter.return_(None)
        builder.add_block(emitter.build_block(exit_id))
        
        builder.set_entry(entry_id)
        builder.add_exit(exit_id)
        
        return builder.build()

    def _compile_pattern(self, pattern: CsqlPattern, ctx: CodeGenContext,
                         emitter: InstructionEmitter, node_reg: Reg,
                         bindings: Dict[str, Reg]) -> Reg:
        """Compile a CSQL pattern into matching code."""
        if isinstance(pattern, CsqlNodePattern):
            return self._compile_node_pattern(pattern, ctx, emitter, node_reg, bindings)
        elif isinstance(pattern, CsqlSequence):
            return self._compile_sequence(pattern, ctx, emitter, node_reg, bindings)
        elif isinstance(pattern, CsqlAlternative):
            return self._compile_alternative(pattern, ctx, emitter, node_reg, bindings)
        elif isinstance(pattern, CsqlOptional):
            return self._compile_optional(pattern, ctx, emitter, node_reg, bindings)
        elif isinstance(pattern, CsqlRepeat):
            return self._compile_repeat(pattern, ctx, emitter, node_reg, bindings)
        else:
            raise CodeGenError(f"Unknown pattern type: {type(pattern).__name__}", pattern)
    
    def _compile_node_pattern(self, pattern: CsqlNodePattern, ctx: CodeGenContext,
                               emitter: InstructionEmitter, node_reg: Reg,
                               bindings: Dict[str, Reg]) -> Reg:
        """
        Compile a node pattern match.
        
        Generates code to:
        1. Check if node matches the expected type
        2. Bind named captures to registers
        3. Evaluate inline predicates
        """
        # Check node type
        type_reg = ctx.fresh_reg("type")
        emitter.load_attr(type_reg, node_reg, "__class__.__name__", pattern)
        
        expected_type = ctx.fresh_reg("exp_type")
        emitter.load_const(expected_type, pattern.node_type, pattern)
        
        type_match = ctx.fresh_reg("type_match")
        emitter.compare(type_match, "==", type_reg, expected_type, pattern)
        
        # If type doesn't match, short-circuit
        # We'll accumulate conditions with AND
        result = type_match
        
        # Process bindings: bind matched parts to named registers
        for binding_name, attr_path in pattern.bindings.items():
            bound_reg = ctx.fresh_reg(f"bind_{binding_name}")
            
            if attr_path == ".":
                # Bind the node itself
                emitter.load_reg(bound_reg, node_reg, pattern)
            else:
                # Bind an attribute
                emitter.load_attr(bound_reg, node_reg, attr_path, pattern)
            
            # Record binding
            bindings[binding_name] = bound_reg
            emitter.match_bind(bound_reg, binding_name, pattern)
            
            # Also bind in symbol table for predicate evaluation
            ctx.bind_symbol(binding_name, bound_reg)
        
        # Evaluate inline predicates
        for pred in pattern.predicates:
            pred_result = self._compile_csql_predicate(pred, ctx, emitter, bindings)
            new_result = ctx.fresh_reg("and_pred")
            emitter.binary_op(new_result, "and", result, pred_result, pred)
            result = new_result
        
        return result
    
    def _compile_sequence(self, pattern: CsqlSequence, ctx: CodeGenContext,
                          emitter: InstructionEmitter, node_reg: Reg,
                          bindings: Dict[str, Reg]) -> Reg:
        """
        Compile a sequence pattern (pattern1, pattern2, ...).
        
        All sub-patterns must match in order. For AST matching, this typically
        means matching children in sequence.
        """
        if not pattern.patterns:
            # Empty sequence always matches
            result = ctx.fresh_reg("true")
            emitter.load_const(result, True, pattern)
            return result
        
        # Get children of current node
        children_reg = ctx.fresh_reg("children")
        emitter.load_attr(children_reg, node_reg, "children", pattern)
        
        # Check we have enough children
        len_reg = ctx.fresh_reg("len")
        emitter.call(len_reg, "len", [children_reg], pattern)
        
        expected_len = ctx.fresh_reg("exp_len")
        emitter.load_const(expected_len, len(pattern.patterns), pattern)
        
        len_check = ctx.fresh_reg("len_ok")
        emitter.compare(len_check, ">=", len_reg, expected_len, pattern)
        
        result = len_check
        
        # Match each sub-pattern against corresponding child
        for i, sub_pattern in enumerate(pattern.patterns):
            child_reg = ctx.fresh_reg(f"child_{i}")
            idx_reg = ctx.fresh_reg(f"idx_{i}")
            emitter.load_const(idx_reg, i, pattern)
            emitter.call(child_reg, "__getitem__", [children_reg, idx_reg], pattern)
            
            sub_result = self._compile_pattern(sub_pattern, ctx, emitter, child_reg, bindings)
            
            new_result = ctx.fresh_reg("seq_and")
            emitter.binary_op(new_result, "and", result, sub_result, pattern)
            result = new_result
        
        return result
    
    def _compile_alternative(self, pattern: CsqlAlternative, ctx: CodeGenContext,
                              emitter: InstructionEmitter, node_reg: Reg,
                              bindings: Dict[str, Reg]) -> Reg:
        """
        Compile an alternative pattern (pattern1 | pattern2 | ...).
        
        Any sub-pattern matching is sufficient.
        """
        if not pattern.patterns:
            # Empty alternative never matches
            result = ctx.fresh_reg("false")
            emitter.load_const(result, False, pattern)
            return result
        
        # Try each alternative with OR
        result = self._compile_pattern(pattern.patterns[0], ctx, emitter, node_reg, bindings)
        
        for sub_pattern in pattern.patterns[1:]:
            # Save current bindings state (alternatives may bind differently)
            sub_bindings: Dict[str, Reg] = {}
            sub_result = self._compile_pattern(sub_pattern, ctx, emitter, node_reg, sub_bindings)
            
            new_result = ctx.fresh_reg("alt_or")
            emitter.binary_op(new_result, "or", result, sub_result, pattern)
            result = new_result
            
            # Merge bindings (last successful match wins)
            bindings.update(sub_bindings)
        
        return result
    
    def _compile_optional(self, pattern: CsqlOptional, ctx: CodeGenContext,
                          emitter: InstructionEmitter, node_reg: Reg,
                          bindings: Dict[str, Reg]) -> Reg:
        """
        Compile an optional pattern (pattern?).
        
        Always succeeds; bindings only set if inner pattern matches.
        """
        # Try to match inner pattern
        inner_bindings: Dict[str, Reg] = {}
        inner_result = self._compile_pattern(pattern.pattern, ctx, emitter, node_reg, inner_bindings)
        
        # Optional always succeeds
        result = ctx.fresh_reg("opt_true")
        emitter.load_const(result, True, pattern)
        
        # Conditionally copy bindings (in real impl, would need PHI nodes or conditional stores)
        # For now, we always set bindings but they may be None/invalid if not matched
        for name, reg in inner_bindings.items():
            bindings[name] = reg
        
        return result
    
    def _compile_repeat(self, pattern: CsqlRepeat, ctx: CodeGenContext,
                        emitter: InstructionEmitter, node_reg: Reg,
                        bindings: Dict[str, Reg]) -> Reg:
        """
        Compile a repeated pattern (pattern* or pattern+ or pattern{n,m}).
        
        Matches the inner pattern multiple times against children/siblings.
        """
        # Get iterable (children or siblings depending on context)
        items_reg = ctx.fresh_reg("items")
        emitter.load_attr(items_reg, node_reg, "children", pattern)
        
        # Count matches
        count_reg = ctx.fresh_reg("count")
        emitter.load_const(count_reg, 0, pattern)
        
        # Accumulated bindings (as list for repeated captures)
        list_bindings: Dict[str, Reg] = {}
        
        # Iterate and count matches
        # In real bytecode, this would be a loop structure
        # Simplified: emit loop setup
        idx_reg = ctx.fresh_reg("idx")
        emitter.load_const(idx_reg, 0, pattern)
        
        len_reg = ctx.fresh_reg("len")
        emitter.call(len_reg, "len", [items_reg], pattern)
        
        # Loop header block would go here in full implementation
        # For now, emit the matching logic inline
        
        item_reg = ctx.fresh_reg("item")
        emitter.call(item_reg, "__iter_current__", [items_reg, idx_reg], pattern)
        
        inner_bindings: Dict[str, Reg] = {}
        inner_result = self._compile_pattern(pattern.pattern, ctx, emitter, item_reg, inner_bindings)
        
        # Increment count if matched
        one_reg = ctx.fresh_reg("one")
        emitter.load_const(one_reg, 1, pattern)
        new_count = ctx.fresh_reg("new_count")
        emitter.binary_op(new_count, "+", count_reg, one_reg, pattern)
        
        # Check count against min/max
        min_reg = ctx.fresh_reg("min")
        emitter.load_const(min_reg, pattern.min_count, pattern)
        
        min_ok = ctx.fresh_reg("min_ok")
        emitter.compare(min_ok, ">=", new_count, min_reg, pattern)
        
        result = min_ok
        
        if pattern.max_count is not None:
            max_reg = ctx.fresh_reg("max")
            emitter.load_const(max_reg, pattern.max_count, pattern)
            
            max_ok = ctx.fresh_reg("max_ok")
            emitter.compare(max_ok, "<=", new_count, max_reg, pattern)
            
            final_result = ctx.fresh_reg("range_ok")
            emitter.binary_op(final_result, "and", result, max_ok, pattern)
            result = final_result
        
        # Merge inner bindings as list capture
        for name, reg in inner_bindings.items():
            list_name = f"{name}__list"
            if list_name not in bindings:
                list_reg = ctx.fresh_reg(f"list_{name}")
                emitter.call(list_reg, "__new_list__", [], pattern)
                bindings[list_name] = list_reg
            emitter.call(ctx.fresh_reg("_"), "__list_append__", 
                        [bindings[list_name], reg], pattern)
        
        return result
    
    def _compile_where(self, where: CsqlExpr, ctx: CodeGenContext,
                       emitter: InstructionEmitter, bindings: Dict[str, Reg]) -> Reg:
        """Compile a WHERE clause filter expression."""
        if isinstance(where, CsqlAnd):
            return self._compile_csql_and(where, ctx, emitter, bindings)
        elif isinstance(where, CsqlOr):
            return self._compile_csql_or(where, ctx, emitter, bindings)
        elif isinstance(where, CsqlNot):
            return self._compile_csql_not(where, ctx, emitter, bindings)
        elif isinstance(where, CsqlPredicate):
            return self._compile_csql_predicate(where, ctx, emitter, bindings)
        elif isinstance(where, CsqlComparison):
            return self._compile_csql_comparison(where, ctx, emitter, bindings)
        else:
            raise CodeGenError(f"Unknown WHERE expression type: {type(where).__name__}", where)
    
    def _compile_csql_and(self, expr: CsqlAnd, ctx: CodeGenContext,
                          emitter: InstructionEmitter, bindings: Dict[str, Reg]) -> Reg:
        """Compile AND conjunction."""
        if not expr.operands:
            result = ctx.fresh_reg("true")
            emitter.load_const(result, True, expr)
            return result
        
        result = self._compile_where(expr.operands[0], ctx, emitter, bindings)
        for operand in expr.operands[1:]:
            next_result = self._compile_where(operand, ctx, emitter, bindings)
            new_result = ctx.fresh_reg("and")
            emitter.binary_op(new_result, "and", result, next_result, expr)
            result = new_result
        return result
    
    def _compile_csql_or(self, expr: CsqlOr, ctx: CodeGenContext,
                         emitter: InstructionEmitter, bindings: Dict[str, Reg]) -> Reg:
        """Compile OR disjunction."""
        if not expr.operands:
            result = ctx.fresh_reg("false")
            emitter.load_const(result, False, expr)
            return result
        
        result = self._compile_where(expr.operands[0], ctx, emitter, bindings)
        for operand in expr.operands[1:]:
            next_result = self._compile_where(operand, ctx, emitter, bindings)
            new_result = ctx.fresh_reg("or")
            emitter.binary_op(new_result, "or", result, next_result, expr)
            result = new_result
        return result
    
    def _compile_csql_not(self, expr: CsqlNot, ctx: CodeGenContext,
                          emitter: InstructionEmitter, bindings: Dict[str, Reg]) -> Reg:
        """Compile NOT negation."""
        inner = self._compile_where(expr.operand, ctx, emitter, bindings)
        result = ctx.fresh_reg("not")
        emitter.unary_op(result, "not", inner, expr)
        return result
    
    def _compile_csql_predicate(self, pred: CsqlPredicate, ctx: CodeGenContext,
                                 emitter: InstructionEmitter, bindings: Dict[str, Reg]) -> Reg:
        """
        Compile a CSQL built-in predicate.
        
        Supported predicates:
        - has_attr(node, attr_name): check if node has attribute
        - is_type(node, type_name): check node type
        - is_const(expr): check if expression is constant
        - is_lvalue(expr): check if expression is lvalue
        - has_side_effects(expr): check for side effects
        - is_null(expr): check for null/nullptr
        - matches_regex(str, pattern): regex match
        - contains(container, element): containment check
        - parent_is(node, type): check parent type
        - has_child(node, type): check for child of type
        - depth(node): get AST depth
        - sibling_before(node): get preceding sibling
        - sibling_after(node): get following sibling
        """
        # Resolve arguments (they may reference bindings)
        arg_regs: List[Reg] = []
        for arg in pred.args:
            if isinstance(arg, CaslIdentifier):
                # Check if it's a binding reference
                if arg.name in bindings:
                    arg_regs.append(bindings[arg.name])
                else:
                    # Generate code for identifier
                    reg = self.expr_gen.visit(arg, ctx, emitter)
                    arg_regs.append(reg)
            else:
                reg = self.expr_gen.visit(arg, ctx, emitter)
                arg_regs.append(reg)
        
        result = ctx.fresh_reg("pred")
        
        # Map predicate to built-in function
        builtin_map = {
            "has_attr": "__csql_has_attr__",
            "is_type": "__csql_is_type__",
            "is_const": "__csql_is_const__",
            "is_lvalue": "__csql_is_lvalue__",
            "has_side_effects": "__csql_has_side_effects__",
            "is_null": "__csql_is_null__",
            "matches_regex": "__csql_matches_regex__",
            "contains": "__csql_contains__",
            "parent_is": "__csql_parent_is__",
            "has_child": "__csql_has_child__",
            "depth": "__csql_depth__",
            "sibling_before": "__csql_sibling_before__",
            "sibling_after": "__csql_sibling_after__",
            # Additional predicates
            "is_pointer": "__csql_is_pointer__",
            "is_array": "__csql_is_array__",
            "is_function": "__csql_is_function__",
            "is_class": "__csql_is_class__",
            "is_template": "__csql_is_template__",
            "is_virtual": "__csql_is_virtual__",
            "is_static": "__csql_is_static__",
            "is_const_qualified": "__csql_is_const_qualified__",
            "is_volatile_qualified": "__csql_is_volatile_qualified__",
            "is_reference": "__csql_is_reference__",
            "is_rvalue_reference": "__csql_is_rvalue_reference__",
            "derives_from": "__csql_derives_from__",
            "has_annotation": "__csql_has_annotation__",
            "in_namespace": "__csql_in_namespace__",
            "file_matches": "__csql_file_matches__",
            "line_range": "__csql_line_range__",
        }
        
        func_name = builtin_map.get(pred.name, f"__csql_{pred.name}__")
        emitter.call(result, func_name, arg_regs, pred)
        
        return result
    
    def _compile_csql_comparison(self, comp: CsqlComparison, ctx: CodeGenContext,
                                  emitter: InstructionEmitter, bindings: Dict[str, Reg]) -> Reg:
        """Compile a comparison expression."""
        # Resolve left operand
        if isinstance(comp.left, CaslIdentifier) and comp.left.name in bindings:
            left_reg = bindings[comp.left.name]
        else:
            left_reg = self.expr_gen.visit(comp.left, ctx, emitter)
        
        # Resolve right operand
        if isinstance(comp.right, CaslIdentifier) and comp.right.name in bindings:
            right_reg = bindings[comp.right.name]
        else:
            right_reg = self.expr_gen.visit(comp.right, ctx, emitter)
        
        result = ctx.fresh_reg("cmp")
        emitter.compare(result, comp.operator, left_reg, right_reg, comp)
        return result


# =============================================================================
# Main Code Generator Orchestrator
# =============================================================================

class CaslCodeGenerator:
    """
    Main CASL code generator that orchestrates compilation of all CASL constructs.
    
    This is the primary entry point for CASL → bytecode compilation.
    
    Usage:
        codegen = CaslCodeGenerator(source_file="rules.casl")
        
        # Add properties
        for prop in properties:
            codegen.add_property(prop)
        
        # Add queries
        for query in queries:
            codegen.add_query(query)
        
        # Generate final program
        program = codegen.generate()
    """
    
    def __init__(self, source_file: Optional[str] = None):
        self.source_file = source_file
        self.program = AbstractProgram(source_file=source_file)
        self.property_gen = PropertyCodeGen()
        self.query_gen = CsqlCodeGen()
        self._ctx = CodeGenContext()
        
        # Track what's been compiled
        self._compiled_properties: List[str] = []
        self._compiled_queries: List[str] = []
        
        # Metadata for checker generation
        self._property_metadata: Dict[str, Dict[str, Any]] = {}
        self._query_metadata: Dict[str, Dict[str, Any]] = {}
    
    def add_property(self, prop: CaslProperty) -> 'CaslCodeGenerator':
        """
        Compile and add a property specification.
        
        Args:
            prop: CASL property AST node
            
        Returns:
            Self for chaining
        """
        # Compile property to monitor function
        func = self.property_gen.compile_property(prop, self._ctx)
        func.source_file = self.source_file
        
        # Add to program
        self.program.add_function(func)
        self._compiled_properties.append(prop.name)
        
        # Store metadata for later use
        self._property_metadata[prop.name] = {
            "pattern": prop.pattern,
            "message": prop.message,
            "severity": prop.severity,
            "function_name": func.name,
            "function_id": func.func_id,
        }
        
        return self
    
    def add_query(self, query: CsqlQuery) -> 'CaslCodeGenerator':
        """
        Compile and add a CSQL query.
        
        Args:
            query: CSQL query AST node
            
        Returns:
            Self for chaining
        """
        # Compile query to matcher function
        func = self.query_gen.compile_query(query, self._ctx)
        func.source_file = self.source_file
        
        # Add to program
        self.program.add_function(func)
        self._compiled_queries.append(query.name)
        
        # Store metadata
        self._query_metadata[query.name] = {
            "select_clause": query.select_clause,
            "function_name": func.name,
            "function_id": func.func_id,
        }
        
        return self
    
    def add_global_initializer(self, name: str, value: Any) -> 'CaslCodeGenerator':
        """
        Add a global initialization instruction.
        
        Used for state machine initial states, configuration, etc.
        """
        dest = self._ctx.named_reg(name)
        instr = Instruction(Opcode.STORE_GLOBAL, (name, value))
        self.program.globals_.append(instr)
        return self
    
    def generate(self) -> AbstractProgram:
        """
        Finalize and return the compiled AbstractProgram.
        
        Returns:
            Complete AbstractProgram ready for execution
        """
        # Add metadata to program
        self.program.metadata["compiled_properties"] = self._compiled_properties
        self.program.metadata["compiled_queries"] = self._compiled_queries
        self.program.metadata["property_metadata"] = self._property_metadata
        self.program.metadata["query_metadata"] = self._query_metadata
        self.program.metadata["source_file"] = self.source_file
        
        return self.program
    
    def generate_checker_registration(self) -> List[Instruction]:
        """
        Generate instructions for registering compiled checkers.
        
        Returns:
            List of instructions to execute for checker registration
        """
        instructions: List[Instruction] = []
        
        for prop_name, metadata in self._property_metadata.items():
            # Generate registration call
            instr = Instruction(
                Opcode.CALL,
                (
                    Reg("_"),  # Discard result
                    "__register_checker__",
                    (prop_name, metadata["function_name"], metadata["severity"]),
                )
            )
            instructions.append(instr)
        
        return instructions
    
    def dump(self) -> str:
        """Return string representation of generated program."""
        return self.program.dump()


# =============================================================================
# Checker Code Generator (Integration with Checker infrastructure)
# =============================================================================

class CheckerCodeGen:
    """
    Generates Checker subclass bytecode from CASL properties.
    
    This integrates compiled properties with the Checker lifecycle:
    - configure()
    - collect_evidence()
    - diagnose()
    - report()
    
    Citation: Checker base class at cppcheckdata-shims-source-code.md lines 16831-16970
    """
    
    def __init__(self):
        self._func_id_counter = itertools.count(2000)
    
    def generate_checker(self, prop: CaslProperty, monitor_func: FunctionCode,
                         ctx: CodeGenContext) -> FunctionCode:
        """
        Generate a Checker-compatible wrapper for a property monitor.
        
        The generated function implements the collect_evidence pattern,
        iterating over events and calling the monitor function.
        """
        builder = FunctionBuilder(
            name=f"__checker_{prop.name}",
            func_id=next(self._func_id_counter)
        )
        
        emitter = InstructionEmitter(ctx)
        
        entry_id = ctx.fresh_block_id()
        loop_header_id = ctx.fresh_block_id()
        loop_body_id = ctx.fresh_block_id()
        loop_exit_id = ctx.fresh_block_id()
        exit_id = ctx.fresh_block_id()
        
        # Parameters: checker context
        builder.add_param("ctx")
        ctx_reg = ctx.named_reg("ctx")
        
        # Entry: get events from context
        emitter.enter_scope(f"checker_{prop.name}", prop)
        events_reg = ctx.fresh_reg("events")
        emitter.load_attr(events_reg, ctx_reg, "events", prop)
        
        # Initialize iterator
        iter_reg = ctx.fresh_reg("iter")
        emitter.call(iter_reg, "iter", [events_reg], prop)
        
        emitter.jump(loop_header_id)
        builder.add_block(emitter.build_block(entry_id))
        
        # Loop header: check for more events
        has_next = ctx.fresh_reg("has_next")
        emitter.call(has_next, "__has_next__", [iter_reg], prop)
        emitter.branch(has_next, loop_body_id, loop_exit_id, prop)
        builder.add_block(emitter.build_block(loop_header_id))
        
        # Loop body: get next event and call monitor
        event_reg = ctx.fresh_reg("event")
        emitter.call(event_reg, "next", [iter_reg], prop)
        
        # Call the monitor function
        monitor_result = ctx.fresh_reg("mon_result")
        emitter.call(monitor_result, monitor_func.name, [event_reg], prop)
        
        # Observe the check
        emitter.observe(f"check_{prop.name}", [event_reg, monitor_result])
        
        emitter.jump(loop_header_id)
        builder.add_block(emitter.build_block(loop_body_id))
        
        # Loop exit
        emitter.event("checker_complete", (prop.name,))
        emitter.jump(exit_id)
        builder.add_block(emitter.build_block(loop_exit_id))
        
        # Exit
        emitter.exit_scope(f"checker_{prop.name}")
        emitter.return_(None)
        builder.add_block(emitter.build_block(exit_id))
        
        builder.set_entry(entry_id)
        builder.add_exit(exit_id)
        
        return builder.build()
    
    def generate_diagnose_function(self, prop: CaslProperty,
                                    ctx: CodeGenContext) -> FunctionCode:
        """
        Generate the diagnose() implementation for a property checker.
        
        This function analyzes collected evidence and emits diagnostics.
        """
        builder = FunctionBuilder(
            name=f"__diagnose_{prop.name}",
            func_id=next(self._func_id_counter)
        )
        
        emitter = InstructionEmitter(ctx)
        
        entry_id = ctx.fresh_block_id()
        check_id = ctx.fresh_block_id()
        emit_id = ctx.fresh_block_id()
        exit_id = ctx.fresh_block_id()
        
        builder.add_param("ctx")
        builder.add_param("evidence")
        ctx_reg = ctx.named_reg("ctx")
        evidence_reg = ctx.named_reg("evidence")
        
        # Entry: check if evidence indicates violation
        emitter.enter_scope(f"diagnose_{prop.name}", prop)
        emitter.jump(check_id)
        builder.add_block(emitter.build_block(entry_id))
        
        # Check evidence
        has_violation = ctx.fresh_reg("has_viol")
        emitter.load_attr(has_violation, evidence_reg, "has_violation", prop)
        emitter.branch(has_violation, emit_id, exit_id, prop)
        builder.add_block(emitter.build_block(check_id))
        
        # Emit diagnostic
        loc_reg = ctx.fresh_reg("loc")
        emitter.load_attr(loc_reg, evidence_reg, "location", prop)
        emitter.emit_diagnostic(
            f"{prop.name}",
            prop.message,
            prop.severity,
            loc_reg,
            prop
        )
        emitter.event("diagnostic_emitted", (prop.name,))
        emitter.jump(exit_id)
        builder.add_block(emitter.build_block(emit_id))
        
        # Exit
        emitter.exit_scope(f"diagnose_{prop.name}")
        emitter.return_(None)
        builder.add_block(emitter.build_block(exit_id))
        
        builder.set_entry(entry_id)
        builder.add_exit(exit_id)
        
        return builder.build()


# =============================================================================
# State Machine Generator (for complex temporal properties)
# =============================================================================

@dataclass
class StateMachineState:
    """State in a property monitoring state machine."""
    id: int
    name: str
    is_initial: bool = False
    is_accepting: bool = False
    is_rejecting: bool = False


@dataclass
class StateMachineTransition:
    """Transition in a property monitoring state machine."""
    from_state: int
    to_state: int
    event: str
    guard: Optional[CaslFormula] = None
    actions: List[str] = field(default_factory=list)


@dataclass
class StateMachine:
    """Complete state machine specification."""
    name: str
    states: Dict[int, StateMachineState] = field(default_factory=dict)
    transitions: List[StateMachineTransition] = field(default_factory=list)
    initial_state: int = 0
    
    def add_state(self, state: StateMachineState) -> None:
        self.states[state.id] = state
        if state.is_initial:
            self.initial_state = state.id
    
    def add_transition(self, trans: StateMachineTransition) -> None:
        self.transitions.append(trans)


class StateMachineCodeGen:
    """
    Generates bytecode for state machine-based property monitors.
    
    Supports:
    - Büchi automata (for LTL properties)
    - Safety automata (for invariants)
    - Response automata (for response patterns)
    """
    
    def __init__(self):
        self._func_id_counter = itertools.count(3000)
        self.expr_gen = ExprCodeGen()
    
    def compile_state_machine(self, sm: StateMachine, ctx: CodeGenContext) -> FunctionCode:
        """
        Compile a state machine into bytecode.
        
        The generated function:
        1. Loads current state
        2. Evaluates transitions based on input event
        3. Updates state
        4. Checks for accepting/rejecting states
        """
        builder = FunctionBuilder(
            name=f"__sm_{sm.name}",
            func_id=next(self._func_id_counter)
        )
        
        emitter = InstructionEmitter(ctx)
        
        # Create blocks for each state
        state_blocks: Dict[int, int] = {}  # state_id -> block_id
        for state_id in sm.states:
            state_blocks[state_id] = ctx.fresh_block_id()
        
        entry_id = ctx.fresh_block_id()
        dispatch_id = ctx.fresh_block_id()
        accept_id = ctx.fresh_block_id()
        reject_id = ctx.fresh_block_id()
        exit_id = ctx.fresh_block_id()
        
        builder.add_param("event")
        event_reg = ctx.named_reg("event")
        
        # Entry: load current state
        emitter.enter_scope(f"sm_{sm.name}")
        state_reg = ctx.fresh_reg("state")
        emitter.load_global(state_reg, f"__sm_state_{sm.name}")
        emitter.jump(dispatch_id)
        builder.add_block(emitter.build_block(entry_id))
        
        # Dispatch: switch on current state
        # Build dispatch chain
        prev_block_id = dispatch_id
        for state_id, block_id in state_blocks.items():
            check_state = ctx.fresh_reg(f"is_s{state_id}")
            expected = ctx.fresh_reg(f"exp_s{state_id}")
            emitter.load_const(expected, state_id)
            emitter.compare(check_state, "==", state_reg, expected)
            
            next_check_id = ctx.fresh_block_id()
            emitter.branch(check_state, block_id, next_check_id)
            builder.add_block(emitter.build_block(prev_block_id))
            prev_block_id = next_check_id
        
        # Default: stay in current state (shouldn't happen)
        emitter.jump(exit_id)
        builder.add_block(emitter.build_block(prev_block_id))
        
        # Generate code for each state
        for state_id, state in sm.states.items():
            block_id = state_blocks[state_id]
            
            # Get transitions from this state
            state_transitions = [t for t in sm.transitions if t.from_state == state_id]
            
            if not state_transitions:
                # No transitions: stay in state
                emitter.jump(exit_id)
                builder.add_block(emitter.build_block(block_id))
                continue
            
            # Evaluate each transition
            current_block = block_id
            for i, trans in enumerate(state_transitions):
                # Check event match
                event_match = ctx.fresh_reg(f"ev_match_{i}")
                expected_event = ctx.fresh_reg(f"exp_ev_{i}")
                event_type = ctx.fresh_reg("ev_type")
                emitter.load_attr(event_type, event_reg, "event_type")
                emitter.load_const(expected_event, trans.event)
                emitter.compare(event_match, "==", event_type, expected_event)
                
                # Check guard if present
                if trans.guard:
                    guard_result = self._compile_guard(trans.guard, ctx, emitter, event_reg)
                    combined = ctx.fresh_reg("combined")
                    emitter.binary_op(combined, "and", event_match, guard_result)
                    event_match = combined
                
                # Branch on match
                take_transition_id = ctx.fresh_block_id()
                next_trans_id = ctx.fresh_block_id()
                
                emitter.branch(event_match, take_transition_id, next_trans_id)
                builder.add_block(emitter.build_block(current_block))
                
                # Take transition block
                new_state = ctx.fresh_reg("new_state")
                emitter.load_const(new_state, trans.to_state)
                emitter.state_transition(trans.from_state, trans.to_state, trans.event)
                
                # Execute actions
                for action in trans.actions:
                    emitter.event(action, (sm.name, trans.from_state, trans.to_state))
                
                # Check if target state is accepting/rejecting
                target_state = sm.states[trans.to_state]
                if target_state.is_accepting:
                    emitter.jump(accept_id)
                elif target_state.is_rejecting:
                    emitter.jump(reject_id)
                else:
                    emitter.jump(exit_id)
                builder.add_block(emitter.build_block(take_transition_id))
                
                current_block = next_trans_id
            
            # No transition matched: stay in state
            emitter.jump(exit_id)
            builder.add_block(emitter.build_block(current_block))
        
        # Accept block
        emitter.event("sm_accepted", (sm.name,))
        emitter.jump(exit_id)
        builder.add_block(emitter.build_block(accept_id))
        
        # Reject block
        loc_reg = ctx.fresh_reg("loc")
        emitter.load_attr(loc_reg, event_reg, "location")
        emitter.emit_diagnostic(
            f"{sm.name}_rejected",
            f"State machine '{sm.name}' entered rejecting state",
            "error",
            loc_reg
        )
        emitter.event("sm_rejected", (sm.name,))
        emitter.jump(exit_id)
        builder.add_block(emitter.build_block(reject_id))
        
        # Exit
        emitter.exit_scope(f"sm_{sm.name}")
        emitter.return_(None)
        builder.add_block(emitter.build_block(exit_id))
        
        builder.set_entry(entry_id)
        builder.add_exit(exit_id)
        
        return builder.build()
    
    def _compile_guard(self, guard: CaslFormula, ctx: CodeGenContext,
                       emitter: InstructionEmitter, event_reg: Reg) -> Reg:
        """Compile a transition guard condition."""
        # Reuse PropertyCodeGen's formula compilation
        prop_gen = PropertyCodeGen()
        return prop_gen._compile_formula(guard, ctx, emitter, event_reg)


# =============================================================================
# Utility Functions
# =============================================================================

def compile_casl_file(source: str, source_file: Optional[str] = None) -> AbstractProgram:
    """
    Convenience function to compile CASL source to AbstractProgram.
    
    Note: This requires casl/parser.py to be available.
    
    Args:
        source: CASL source code
        source_file: Optional source file name for diagnostics
        
    Returns:
        Compiled AbstractProgram
    """
    # This would integrate with casl/parser.py when available
    raise NotImplementedError(
        "Full CASL compilation requires casl/parser.py. "
        "Use CaslCodeGenerator directly with pre-parsed AST nodes."
    )


def compile_property(prop: CaslProperty, source_file: Optional[str] = None) -> AbstractProgram:
    """
    Compile a single property to AbstractProgram.
    
    Args:
        prop: Property AST node
        source_file: Optional source file name
        
    Returns:
        AbstractProgram containing the compiled property monitor
    """
    codegen = CaslCodeGenerator(source_file=source_file)
    codegen.add_property(prop)
    return codegen.generate()


def compile_query(query: CsqlQuery, source_file: Optional[str] = None) -> AbstractProgram:
    """
    Compile a single CSQL query to AbstractProgram.
    
    Args:
        query: CSQL query AST node
        source_file: Optional source file name
        
    Returns:
        AbstractProgram containing the compiled query matcher
    """
    codegen = CaslCodeGenerator(source_file=source_file)
    codegen.add_query(query)
    return codegen.generate()


# =============================================================================
# Export Public API
# =============================================================================

__all__ = [
    # Core types (would be imported from cppcheckdata in production)
    "Reg",
    "BlockRef",
    "EventRef",
    "ObserverRef",
    "Opcode",
    "Instruction",
    "CodeBlock",
    "FunctionCode",
    "AbstractProgram",
    
    # CASL AST nodes
    "CaslNode",
    "CaslType",
    "CaslProperty",
    "CaslFormula",
    "CaslPredicate",
    "CaslExpr",
    "CaslIdentifier",
    "CaslLiteral",
    "CaslBinaryOp",
    "CaslUnaryOp",
    "CaslCall",
    "CaslAttrAccess",
    
    # CSQL AST nodes
    "CsqlQuery",
    "CsqlPattern",
    "CsqlNodePattern",
    "CsqlSequence",
    "CsqlAlternative",
    "CsqlOptional",
    "CsqlRepeat",
    "CsqlExpr",
    "CsqlAnd",
    "CsqlOr",
    "CsqlNot",
    "CsqlPredicate",
    "CsqlComparison",
    
    # Code generation infrastructure
    "CodeGenError",
    "CodeGenContext",
    "InstructionEmitter",
    "FunctionBuilder",
    
    # Visitors and generators
    "CaslCodeGenVisitor",
    "ExprCodeGen",
    "PropertyCodeGen",
    "CsqlCodeGen",
    "CaslCodeGenerator",
    "CheckerCodeGen",
    
    # State machine
    "StateMachineState",
    "StateMachineTransition",
    "StateMachine",
    "StateMachineCodeGen",
    
    # Utility functions
    "compile_casl_file",
    "compile_property",
    "compile_query",
]

