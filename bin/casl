#!/usr/bin/env bash
# =============================================================================
#  bin/casl — Development wrapper for the CASL toolchain
#
#  This script invokes the CASL CLI by running `python3 -m casl`, which
#  delegates to casl/__main__.py → main().
#
#  Usage:
#      bin/casl <command> [options] <spec-file>
#
#  Examples:
#      bin/casl compile spec.casl -o addon.py
#      bin/casl check spec.casl
#      bin/casl dump-ast spec.casl
#      bin/casl dump-sexp spec.casl
#      bin/casl run spec.casl program.c.dump
#      bin/casl info spec.casl
#      bin/casl init my-checker.casl
#      bin/casl --version
#      bin/casl --help
#
#  Notes:
#      • When the package is installed via `pip install .` or
#        `pip install -e .`, setuptools creates a platform-appropriate
#        `casl` wrapper from the console_scripts entry point
#        (casl.__main__:main).  This shell script is therefore only
#        needed for running directly from a source checkout without
#        installing.
#
#      • The script resolves its own location so that it works correctly
#        regardless of the current working directory:
#            cd /tmp && /path/to/cppcheckdata-shims/bin/casl --help
#
#      • PYTHON can be overridden to use a specific interpreter:
#            PYTHON=python3.12 bin/casl compile spec.casl
# =============================================================================

set -euo pipefail

# ---------------------------------------------------------------------------
#  Resolve the repository root.
#
#  bin/casl lives at <repo>/bin/casl, so the repo root is one level up.
#  We resolve symlinks so that the script works even when symlinked from
#  another location (e.g. ~/bin/casl → /home/user/src/shims/bin/casl).
# ---------------------------------------------------------------------------
SCRIPT_SOURCE="${BASH_SOURCE[0]}"

# Chase symlinks to find the real location of this script.
while [ -L "$SCRIPT_SOURCE" ]; do
    SCRIPT_DIR="$(cd -P "$(dirname "$SCRIPT_SOURCE")" && pwd)"
    SCRIPT_SOURCE="$(readlink "$SCRIPT_SOURCE")"
    # If the readlink result is relative, resolve it against the dir.
    [[ "$SCRIPT_SOURCE" != /* ]] && SCRIPT_SOURCE="$SCRIPT_DIR/$SCRIPT_SOURCE"
done

SCRIPT_DIR="$(cd -P "$(dirname "$SCRIPT_SOURCE")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# ---------------------------------------------------------------------------
#  Determine the Python interpreter.
#
#  Honour the PYTHON environment variable if set; otherwise fall back to
#  python3, then python.
# ---------------------------------------------------------------------------
if [ -n "${PYTHON:-}" ]; then
    PYTHON_BIN="$PYTHON"
elif command -v python3 &>/dev/null; then
    PYTHON_BIN="python3"
elif command -v python &>/dev/null; then
    PYTHON_BIN="python"
else
    echo "error: cannot find a Python interpreter." >&2
    echo "       Set the PYTHON environment variable or ensure python3 is on PATH." >&2
    exit 127
fi

# ---------------------------------------------------------------------------
#  Ensure the repo root is on PYTHONPATH so that `python -m casl` can
#  locate the casl package (and cppcheckdata_shims) without installation.
# ---------------------------------------------------------------------------
if [ -n "${PYTHONPATH:-}" ]; then
    export PYTHONPATH="$REPO_ROOT:$PYTHONPATH"
else
    export PYTHONPATH="$REPO_ROOT"
fi

# ---------------------------------------------------------------------------
#  Execute.
#
#  `exec` replaces this shell process with the Python process so that
#  signals (SIGINT, SIGTERM) are delivered directly to the Python
#  interpreter and the exit code propagates correctly.
# ---------------------------------------------------------------------------
exec "$PYTHON_BIN" -m casl "$@"
