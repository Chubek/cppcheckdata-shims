;;;; ═══════════════════════════════════════════════════════════════════
;;;;  IntegerLint.casl
;;;;  Integer Safety Analyzer — CASL Specification
;;;;
;;;;  Generates IntegerLint.py via:   casl IntegerLint.casl
;;;;
;;;;  Target CWEs: 128, 190, 191, 192, 193, 194, 195, 196, 197, 681
;;;;
;;;;  Architecture: Eight analysis passes (one pre-pass + seven checkers)
;;;;    1. value-tracker          — lightweight forward interval tracking
;;;;    2. overflow-underflow     — CWE-190, CWE-191
;;;;    3. truncation             — CWE-192, CWE-197
;;;;    4. sign-conversion        — CWE-194, CWE-195, CWE-196, CWE-681
;;;;    5. off-by-one             — CWE-193
;;;;    6. allocation-overflow    — CWE-128, CWE-190
;;;;    7. mixed-sign-comparison  — CWE-681
;;;;    8. shift-overflow         — CWE-190
;;;; ═══════════════════════════════════════════════════════════════════

(casl-version 1)

;; ─────────────────────────────────────────────────────────────────────
;;  ADDON METADATA
;; ─────────────────────────────────────────────────────────────────────

(addon IntegerLint
  (version "1.0.0")
  (description "Integer safety analyzer detecting overflow, underflow, truncation, sign-conversion, off-by-one, allocation-overflow, mixed-sign comparison, and shift-overflow vulnerabilities.")
  (author "IntegerLint Authors")
  (license "MIT")
  (cwe 128 190 191 192 193 194 195 196 197 681)
  (tags "integer" "overflow" "underflow" "truncation" "sign" "safety"))

;; ─────────────────────────────────────────────────────────────────────
;;  IMPORTS AND DEPENDENCIES
;; ─────────────────────────────────────────────────────────────────────

(imports
  (python "sys")
  (python "re")
  (cppcheckdata))

;; ─────────────────────────────────────────────────────────────────────
;;  DOMAIN DECLARATION — IntervalDomain
;;
;;  We request the public IntervalDomain from cppcheckdata_shims.
;;  CASL will generate a fully self-contained fallback if the shims
;;  library is not installed at runtime.
;; ─────────────────────────────────────────────────────────────────────

(domain IntervalDomain
  (description "Integer interval [lo, hi] ⊆ ℤ with full arithmetic transfer functions.")
  (optional-import cppcheckdata_shims.abstract_domains IntervalDomain)
  (fallback
    (python-block "
class IntervalDomain:
    \"\"\"Interval abstract domain [lo, hi] with arithmetic.\"\"\"
    __slots__ = ('lo', 'hi', '_is_bottom')

    def __init__(self, lo=0, hi=0, bottom=False):
        if bottom:
            self.lo = 1
            self.hi = 0
            self._is_bottom = True
        else:
            self.lo = lo
            self.hi = hi
            self._is_bottom = False

    @classmethod
    def bottom(cls):
        return cls(bottom=True)

    @classmethod
    def top(cls):
        return cls(-(1 << 63), (1 << 63) - 1)

    @classmethod
    def const(cls, v):
        return cls(v, v)

    @classmethod
    def range(cls, lo, hi):
        if lo > hi:
            return cls.bottom()
        return cls(lo, hi)

    def is_bottom(self):
        return self._is_bottom

    def is_top(self):
        return not self._is_bottom and self.lo == -(1 << 63) and self.hi == (1 << 63) - 1

    def contains(self, v):
        if self._is_bottom:
            return False
        return self.lo <= v <= self.hi

    def overlaps(self, other):
        if self._is_bottom or other._is_bottom:
            return False
        return self.lo <= other.hi and other.lo <= self.hi

    def join(self, other):
        if self._is_bottom:
            return other
        if other._is_bottom:
            return self
        return IntervalDomain(min(self.lo, other.lo), max(self.hi, other.hi))

    def meet(self, other):
        if self._is_bottom or other._is_bottom:
            return IntervalDomain.bottom()
        lo = max(self.lo, other.lo)
        hi = min(self.hi, other.hi)
        if lo > hi:
            return IntervalDomain.bottom()
        return IntervalDomain(lo, hi)

    def widen(self, other):
        if self._is_bottom:
            return other
        if other._is_bottom:
            return self
        lo = self.lo if other.lo >= self.lo else -(1 << 63)
        hi = self.hi if other.hi <= self.hi else (1 << 63) - 1
        return IntervalDomain(lo, hi)

    def add(self, other):
        if self._is_bottom or other._is_bottom:
            return IntervalDomain.bottom()
        return IntervalDomain(self.lo + other.lo, self.hi + other.hi)

    def sub(self, other):
        if self._is_bottom or other._is_bottom:
            return IntervalDomain.bottom()
        return IntervalDomain(self.lo - other.hi, self.hi - other.lo)

    def mul(self, other):
        if self._is_bottom or other._is_bottom:
            return IntervalDomain.bottom()
        products = [self.lo * other.lo, self.lo * other.hi,
                    self.hi * other.lo, self.hi * other.hi]
        return IntervalDomain(min(products), max(products))

    def neg(self):
        if self._is_bottom:
            return IntervalDomain.bottom()
        return IntervalDomain(-self.hi, -self.lo)

    def lshift(self, other):
        if self._is_bottom or other._is_bottom:
            return IntervalDomain.bottom()
        if other.lo < 0:
            return IntervalDomain.top()
        if other.hi > 63:
            return IntervalDomain.top()
        results = []
        for s in [other.lo, other.hi]:
            results.append(self.lo << s)
            results.append(self.hi << s)
        return IntervalDomain(min(results), max(results))

    def can_exceed(self, bound):
        if self._is_bottom:
            return False
        return self.hi > bound

    def can_be_below(self, bound):
        if self._is_bottom:
            return False
        return self.lo < bound

    def can_be_negative(self):
        return self.can_be_below(0)

    def __repr__(self):
        if self._is_bottom:
            return 'IntervalDomain(⊥)'
        return f'IntervalDomain([{self.lo}, {self.hi}])'

    def __eq__(self, other):
        if not isinstance(other, IntervalDomain):
            return NotImplemented
        if self._is_bottom and other._is_bottom:
            return True
        if self._is_bottom or other._is_bottom:
            return False
        return self.lo == other.lo and self.hi == other.hi

    def __hash__(self):
        if self._is_bottom:
            return hash(('bottom',))
        return hash((self.lo, self.hi))
")))

;; ─────────────────────────────────────────────────────────────────────
;;  GLOBAL HELPERS
;;
;;  These are emitted as module-level Python functions/constants in
;;  the generated addon. They provide the type-size oracle, platform
;;  model, and reusable analysis utilities.
;; ─────────────────────────────────────────────────────────────────────

(helpers

  ;; ── Platform Model (LP64) ──────────────────────────────────────────

  (helper type-size-table
    (description "LP64 platform model: type name → (bits, signed?)")
    (python-block "
# TYPE_INFO: canonical_name -> (bit_width, is_signed)
TYPE_INFO = {
    'bool':                (8,  False),
    '_Bool':               (8,  False),
    'char':                (8,  True),
    'signed char':         (8,  True),
    'unsigned char':       (8,  False),
    'uint8_t':             (8,  False),
    'int8_t':              (8,  True),
    'short':               (16, True),
    'signed short':        (16, True),
    'short int':           (16, True),
    'signed short int':    (16, True),
    'unsigned short':      (16, False),
    'unsigned short int':  (16, False),
    'uint16_t':            (16, False),
    'int16_t':             (16, True),
    'int':                 (32, True),
    'signed':              (32, True),
    'signed int':          (32, True),
    'unsigned':            (32, False),
    'unsigned int':        (32, False),
    'uint32_t':            (32, False),
    'int32_t':             (32, True),
    'long':                (64, True),
    'signed long':         (64, True),
    'long int':            (64, True),
    'signed long int':     (64, True),
    'unsigned long':       (64, False),
    'unsigned long int':   (64, False),
    'long long':           (64, True),
    'signed long long':    (64, True),
    'long long int':       (64, True),
    'signed long long int':(64, True),
    'unsigned long long':  (64, False),
    'unsigned long long int': (64, False),
    'uint64_t':            (64, False),
    'int64_t':             (64, True),
    'size_t':              (64, False),
    'ssize_t':             (64, True),
    'ptrdiff_t':           (64, True),
    'uintptr_t':           (64, False),
    'intptr_t':            (64, True),
}
"))

  ;; ── Type Resolution Helpers ────────────────────────────────────────

  (helper resolve-type-info
    (description "Resolve a token's type to (bits, signed) using valueType or name lookup.")
    (python-block "
def _vt_to_canonical(vt):
    \"\"\"Convert a cppcheckdata ValueType to a canonical type name.\"\"\"
    if vt is None:
        return None
    if vt.originalTypeName and vt.originalTypeName in TYPE_INFO:
        return vt.originalTypeName
    base = vt.type  # 'char','short','int','long','long long','float','double'
    if base in ('float', 'double', 'long double'):
        return None  # not integer
    sign = getattr(vt, 'sign', None)
    if sign == 'unsigned':
        return 'unsigned ' + (base or 'int')
    elif base:
        return base
    return None

def get_type_info_vt(vt):
    \"\"\"Return (bits, signed) for a ValueType, or None.\"\"\"
    name = _vt_to_canonical(vt)
    if name and name in TYPE_INFO:
        return TYPE_INFO[name]
    return None

def get_type_info_token(tok):
    \"\"\"Return (bits, is_signed) for a token, or None.\"\"\"
    if tok is None:
        return None
    vt = getattr(tok, 'valueType', None)
    if vt:
        info = get_type_info_vt(vt)
        if info:
            return info
    return None

def type_range(bits, signed):
    \"\"\"Return (min_val, max_val) for an integer type.\"\"\"
    if signed:
        return (-(1 << (bits - 1)), (1 << (bits - 1)) - 1)
    else:
        return (0, (1 << bits) - 1)

def is_pointer_type(tok):
    \"\"\"Check if a token has pointer type.\"\"\"
    vt = getattr(tok, 'valueType', None)
    if vt and getattr(vt, 'pointer', 0) and vt.pointer > 0:
        return True
    return False

def is_integer_type(tok):
    \"\"\"Check if a token has integer type.\"\"\"
    return get_type_info_token(tok) is not None

def get_bits(tok):
    \"\"\"Get bit-width of a token's type, or None.\"\"\"
    info = get_type_info_token(tok)
    return info[0] if info else None

def is_signed(tok):
    \"\"\"Check if a token's type is signed.\"\"\"
    info = get_type_info_token(tok)
    return info[1] if info else None

def is_unsigned(tok):
    \"\"\"Check if a token's type is unsigned.\"\"\"
    info = get_type_info_token(tok)
    if info is None:
        return None
    return not info[1]
"))

  ;; ── Deduplication Helper ───────────────────────────────────────────

  (helper dedup-tracker
    (description "Tracks reported (file, line, cwe) triples to avoid duplicate diagnostics.")
    (python-block "
_reported_set = set()

def _already_reported(file, line, cwe_id):
    key = (file, line, cwe_id)
    if key in _reported_set:
        return True
    _reported_set.add(key)
    return False
"))

  ;; ── Interval Estimation for Tokens ─────────────────────────────────

  (helper interval-from-token
    (description "Estimate an IntervalDomain for a token from Cppcheck value-flow data.")
    (python-block "
def interval_from_values(tok):
    \"\"\"Build an IntervalDomain from cppcheck .values list on a token.\"\"\"
    vals = getattr(tok, 'values', None)
    if not vals:
        return None
    int_vals = []
    for v in vals:
        iv = getattr(v, 'intvalue', None)
        if iv is not None:
            int_vals.append(iv)
    if not int_vals:
        return None
    return IntervalDomain(min(int_vals), max(int_vals))

def interval_from_number(tok):
    \"\"\"Build a constant interval if the token is a literal number.\"\"\"
    if tok and getattr(tok, 'isNumber', False):
        try:
            s = tok.str.rstrip('uUlL')
            if s.startswith('0x') or s.startswith('0X'):
                v = int(s, 16)
            elif s.startswith('0b') or s.startswith('0B'):
                v = int(s, 2)
            elif len(s) > 1 and s.startswith('0') and s.isdigit():
                v = int(s, 8)
            else:
                v = int(s)
            return IntervalDomain.const(v)
        except (ValueError, OverflowError):
            pass
    return None
"))

  ;; ── AST Traversal Helpers ──────────────────────────────────────────

  (helper ast-utils
    (description "Utilities for walking and querying the AST overlay on token lists.")
    (python-block "
def get_ast_operand(tok, which):
    \"\"\"Get astOperand1 or astOperand2 safely.\"\"\"
    if which == 1:
        return getattr(tok, 'astOperand1', None)
    elif which == 2:
        return getattr(tok, 'astOperand2', None)
    return None

def expr_tokens(tok):
    \"\"\"Yield all tokens in the AST subtree rooted at tok (pre-order).\"\"\"
    if tok is None:
        return
    yield tok
    yield from expr_tokens(getattr(tok, 'astOperand1', None))
    yield from expr_tokens(getattr(tok, 'astOperand2', None))

def find_parent_op(tok, op_str):
    \"\"\"Walk up astParent chain looking for an operator.\"\"\"
    cur = getattr(tok, 'astParent', None)
    while cur:
        if cur.str == op_str:
            return cur
        cur = getattr(cur, 'astParent', None)
    return None

def is_in_sizeof(tok):
    \"\"\"Check if token is inside a sizeof() expression.\"\"\"
    cur = getattr(tok, 'astParent', None)
    while cur:
        if cur.str == 'sizeof':
            return True
        cur = getattr(cur, 'astParent', None)
    return False

def is_in_cast(tok):
    \"\"\"Check if the token is the cast-type of a cast expression.\"\"\"
    parent = getattr(tok, 'astParent', None)
    if parent and parent.str == '(' and getattr(parent, 'isCast', False):
        return True
    return False

def is_cast_token(tok):
    \"\"\"Check if a token IS a cast expression.\"\"\"
    return tok.str == '(' and getattr(tok, 'isCast', False)

def get_enclosing_function(tok):
    \"\"\"Get the enclosing function scope of a token.\"\"\"
    scope = getattr(tok, 'scope', None)
    while scope:
        if getattr(scope, 'type', '') == 'Function':
            return scope
        scope = getattr(scope, 'nestedIn', None)
    return None
"))

  ;; ── Report Helper ──────────────────────────────────────────────────

  (helper report-finding
    (description "Emit a cppcheck-compatible diagnostic.")
    (python-block "
def report_finding(tok, severity, msg, cwe_id, addon_name='IntegerLint'):
    \"\"\"Report a finding in cppcheck addon format.\"\"\"
    file_ = getattr(tok, 'file', '<unknown>')
    line = getattr(tok, 'linenr', 0)
    col = getattr(tok, 'column', 0)
    if _already_reported(file_, line, cwe_id):
        return
    # Cppcheck addon output format
    sys.stdout.write(
        f'[{file_}:{line}:{col}] ({severity}) {addon_name}: {msg} [CWE-{cwe_id}]\\n'
    )
    sys.stdout.flush()
")))

;; ═════════════════════════════════════════════════════════════════════
;;  STATE DECLARATIONS
;;
;;  Shared mutable state used by the value-tracker pre-pass and
;;  consumed by subsequent checker passes.
;; ═════════════════════════════════════════════════════════════════════

(state
  (description "Global state for the value-tracking pre-pass.")
  (python-block "
# var_id -> IntervalDomain
_var_intervals = {}

def set_var_interval(var_id, interval):
    if var_id is None:
        return
    if var_id in _var_intervals:
        _var_intervals[var_id] = _var_intervals[var_id].join(interval)
    else:
        _var_intervals[var_id] = interval

def get_var_interval(var_id):
    return _var_intervals.get(var_id)

def get_token_interval(tok):
    \"\"\"Estimate interval for a token: literal, value-flow, or variable state.\"\"\"
    if tok is None:
        return None
    # 1. Literal number
    iv = interval_from_number(tok)
    if iv is not None:
        return iv
    # 2. Cppcheck value-flow data
    iv = interval_from_values(tok)
    if iv is not None:
        return iv
    # 3. Tracked variable
    vid = getattr(tok, 'varId', None)
    if vid and vid in _var_intervals:
        return _var_intervals[vid]
    # 4. Unary minus
    if tok.str == '-' and getattr(tok, 'astOperand1', None) and not getattr(tok, 'astOperand2', None):
        sub = get_token_interval(tok.astOperand1)
        if sub:
            return sub.neg()
    # 5. Binary operations
    op1 = getattr(tok, 'astOperand1', None)
    op2 = getattr(tok, 'astOperand2', None)
    if op1 and op2:
        iv1 = get_token_interval(op1)
        iv2 = get_token_interval(op2)
        if iv1 and iv2:
            if tok.str == '+':
                return iv1.add(iv2)
            elif tok.str == '-':
                return iv1.sub(iv2)
            elif tok.str == '*':
                return iv1.mul(iv2)
            elif tok.str == '<<':
                return iv1.lshift(iv2)
    return None
"))

;; ═════════════════════════════════════════════════════════════════════
;;  PASS 1: VALUE TRACKER (Pre-pass)
;;
;;  Lightweight forward scan that populates _var_intervals from
;;  assignments, declarations, and literals. No fixpoint, no CFG —
;;  single linear pass over the token list.
;; ═════════════════════════════════════════════════════════════════════

(pass value-tracker
  (description "Forward value-tracking pre-pass. Estimates integer intervals for variables by scanning assignments.")
  (strategy linear-forward)
  (order 0)

  ;; Rule VT-1: Track simple assignments  var = expr;
  (rule track-assignment
    (description "Track interval of RHS into the assigned variable.")
    (match
      (token @eq)
      (constraint (python-pred
        "@eq.str == '=' and not getattr(@eq, 'isCast', False) and "
        "getattr(@eq, 'astOperand1', None) is not None and "
        "getattr(@eq.astOperand1, 'varId', None) is not None and "
        "getattr(@eq, 'astOperand2', None) is not None")))
    (action
      (python-block "
rhs_interval = get_token_interval(@eq.astOperand2)
if rhs_interval is not None:
    set_var_interval(@eq.astOperand1.varId, rhs_interval)
")))

  ;; Rule VT-2: Track initializations from declarations  int x = 5;
  (rule track-init-decl
    (description "Track interval from variable initializers.")
    (match
      (token @tok)
      (constraint (python-pred
        "getattr(@tok, 'variable', None) is not None and "
        "getattr(@tok.variable, 'nameToken', None) is @tok and "
        "@tok.next is not None and @tok.next.str == '='")))
    (action
      (python-block "
rhs_tok = getattr(@tok.next, 'astOperand2', None)
if rhs_tok is None:
    rhs_tok = @tok.next.next  # fallback: token after '='
if rhs_tok is not None:
    rhs_interval = get_token_interval(rhs_tok)
    if rhs_interval is not None:
        vid = getattr(@tok, 'varId', None)
        if vid:
            set_var_interval(vid, rhs_interval)
")))

  ;; Rule VT-3: Track compound assignment  var += expr, var -= expr, etc.
  (rule track-compound-assign
    (description "Track interval updates from compound assignment operators.")
    (match
      (token @op)
      (constraint (python-pred
        "@op.str in ('+=', '-=', '*=', '<<=') and "
        "getattr(@op, 'astOperand1', None) is not None and "
        "getattr(@op.astOperand1, 'varId', None) is not None and "
        "getattr(@op, 'astOperand2', None) is not None")))
    (action
      (python-block "
vid = @op.astOperand1.varId
cur = get_var_interval(vid)
rhs = get_token_interval(@op.astOperand2)
if cur is not None and rhs is not None:
    if @op.str == '+=':
        set_var_interval(vid, cur.add(rhs))
    elif @op.str == '-=':
        set_var_interval(vid, cur.sub(rhs))
    elif @op.str == '*=':
        set_var_interval(vid, cur.mul(rhs))
    elif @op.str == '<<=':
        set_var_interval(vid, cur.lshift(rhs))
elif rhs is not None and cur is None:
    # First time seeing this variable, initialize with RHS
    pass  # can't infer without current value
")))
)

;; ═════════════════════════════════════════════════════════════════════
;;  PASS 2: OVERFLOW / UNDERFLOW CHECK  (CWE-190, CWE-191)
;;
;;  Detects arithmetic operations (+, -, *, <<) whose result interval
;;  can exceed the destination type's range.
;; ═════════════════════════════════════════════════════════════════════

(pass overflow-underflow
  (description "Detect integer overflow (CWE-190) and underflow (CWE-191) in arithmetic operations.")
  (strategy linear-forward)
  (order 1)

  ;; Rule OUF-1: Addition overflow/underflow
  (rule addition-overflow
    (description "Detect overflow/underflow in addition operations.")
    (match
      (token @op)
      (constraint (python-pred
        "@op.str == '+' and "
        "getattr(@op, 'astOperand1', None) is not None and "
        "getattr(@op, 'astOperand2', None) is not None and "
        "not is_in_sizeof(@op) and "
        "not is_pointer_type(@op.astOperand1) and "
        "not is_pointer_type(@op.astOperand2) and "
        "is_integer_type(@op.astOperand1) or is_integer_type(@op.astOperand2)")))
    (action
      (python-block "
op1 = @op.astOperand1
op2 = @op.astOperand2
iv1 = get_token_interval(op1)
iv2 = get_token_interval(op2)
if iv1 is not None and iv2 is not None:
    result = iv1.add(iv2)
    # Determine destination type from operator or parent assignment
    dest_tok = @op
    parent = getattr(@op, 'astParent', None)
    if parent and parent.str == '=' and getattr(parent, 'astOperand1', None):
        dest_tok = parent.astOperand1
    info = get_type_info_token(dest_tok)
    if info is None:
        info = get_type_info_token(op1)
    if info is not None:
        bits, signed = info
        tmin, tmax = type_range(bits, signed)
        if result.can_exceed(tmax):
            report_finding(@op, 'warning',
                f\"Integer overflow in addition: result [{result.lo}, {result.hi}] \"
                f\"exceeds max {tmax} for {bits}-bit {'signed' if signed else 'unsigned'} type\",
                190)
        if result.can_be_below(tmin):
            report_finding(@op, 'warning',
                f\"Integer underflow in addition: result [{result.lo}, {result.hi}] \"
                f\"below min {tmin} for {bits}-bit {'signed' if signed else 'unsigned'} type\",
                191)
")))

  ;; Rule OUF-2: Subtraction overflow/underflow
  (rule subtraction-overflow
    (description "Detect overflow/underflow in subtraction operations.")
    (match
      (token @op)
      (constraint (python-pred
        "@op.str == '-' and "
        "getattr(@op, 'astOperand1', None) is not None and "
        "getattr(@op, 'astOperand2', None) is not None and "
        "not is_in_sizeof(@op) and "
        "not is_pointer_type(@op.astOperand1) and "
        "is_integer_type(@op.astOperand1) or is_integer_type(@op.astOperand2)")))
    (action
      (python-block "
op1 = @op.astOperand1
op2 = @op.astOperand2
iv1 = get_token_interval(op1)
iv2 = get_token_interval(op2)
if iv1 is not None and iv2 is not None:
    result = iv1.sub(iv2)
    dest_tok = @op
    parent = getattr(@op, 'astParent', None)
    if parent and parent.str == '=' and getattr(parent, 'astOperand1', None):
        dest_tok = parent.astOperand1
    info = get_type_info_token(dest_tok)
    if info is None:
        info = get_type_info_token(op1)
    if info is not None:
        bits, signed = info
        tmin, tmax = type_range(bits, signed)
        if result.can_exceed(tmax):
            report_finding(@op, 'warning',
                f\"Integer overflow in subtraction: result [{result.lo}, {result.hi}] \"
                f\"exceeds max {tmax} for {bits}-bit {'signed' if signed else 'unsigned'} type\",
                190)
        if result.can_be_below(tmin):
            report_finding(@op, 'warning',
                f\"Integer underflow in subtraction: result [{result.lo}, {result.hi}] \"
                f\"below min {tmin} for {bits}-bit {'signed' if signed else 'unsigned'} type\",
                191)
")))

  ;; Rule OUF-3: Multiplication overflow/underflow
  (rule multiplication-overflow
    (description "Detect overflow/underflow in multiplication operations.")
    (match
      (token @op)
      (constraint (python-pred
        "@op.str == '*' and "
        "getattr(@op, 'astOperand1', None) is not None and "
        "getattr(@op, 'astOperand2', None) is not None and "
        "not is_in_sizeof(@op) and "
        "is_integer_type(@op.astOperand1) or is_integer_type(@op.astOperand2)")))
    (action
      (python-block "
op1 = @op.astOperand1
op2 = @op.astOperand2
iv1 = get_token_interval(op1)
iv2 = get_token_interval(op2)
if iv1 is not None and iv2 is not None:
    result = iv1.mul(iv2)
    dest_tok = @op
    parent = getattr(@op, 'astParent', None)
    if parent and parent.str == '=' and getattr(parent, 'astOperand1', None):
        dest_tok = parent.astOperand1
    info = get_type_info_token(dest_tok)
    if info is None:
        info = get_type_info_token(op1)
    if info is not None:
        bits, signed = info
        tmin, tmax = type_range(bits, signed)
        if result.can_exceed(tmax):
            report_finding(@op, 'warning',
                f\"Integer overflow in multiplication: result [{result.lo}, {result.hi}] \"
                f\"exceeds max {tmax} for {bits}-bit {'signed' if signed else 'unsigned'} type\",
                190)
        if result.can_be_below(tmin):
            report_finding(@op, 'warning',
                f\"Integer underflow in multiplication: result [{result.lo}, {result.hi}] \"
                f\"below min {tmin} for {bits}-bit {'signed' if signed else 'unsigned'} type\",
                191)
")))

  ;; Rule OUF-4: Left-shift overflow
  (rule lshift-overflow
    (description "Detect overflow from left-shift operations.")
    (match
      (token @op)
      (constraint (python-pred
        "@op.str == '<<' and "
        "getattr(@op, 'astOperand1', None) is not None and "
        "getattr(@op, 'astOperand2', None) is not None and "
        "not is_in_sizeof(@op)")))
    (action
      (python-block "
op1 = @op.astOperand1
op2 = @op.astOperand2
iv1 = get_token_interval(op1)
iv2 = get_token_interval(op2)
if iv1 is not None and iv2 is not None:
    result = iv1.lshift(iv2)
    info = get_type_info_token(op1)
    if info is not None:
        bits, signed = info
        tmin, tmax = type_range(bits, signed)
        if not result.is_top() and result.can_exceed(tmax):
            report_finding(@op, 'warning',
                f\"Integer overflow in left-shift: result can exceed max {tmax} \"
                f\"for {bits}-bit {'signed' if signed else 'unsigned'} type\",
                190)
")))
)

;; ═════════════════════════════════════════════════════════════════════
;;  PASS 3: TRUNCATION CHECK  (CWE-192, CWE-197)
;;
;;  Detects narrowing assignments/casts where the source type has
;;  more bits than the destination, and the value range can lose
;;  significant data.
;; ═════════════════════════════════════════════════════════════════════

(pass truncation
  (description "Detect integer truncation (CWE-192) and numeric truncation (CWE-197) in narrowing conversions.")
  (strategy linear-forward)
  (order 2)

  ;; Rule TR-1: Narrowing assignment
  (rule narrowing-assignment
    (description "Detect narrowing in assignments where destination type is smaller than source.")
    (match
      (token @eq)
      (constraint (python-pred
        "@eq.str == '=' and "
        "not getattr(@eq, 'isCast', False) and "
        "getattr(@eq, 'astOperand1', None) is not None and "
        "getattr(@eq, 'astOperand2', None) is not None")))
    (action
      (python-block "
lhs = @eq.astOperand1
rhs = @eq.astOperand2
lhs_info = get_type_info_token(lhs)
rhs_info = get_type_info_token(rhs)
if lhs_info and rhs_info:
    lhs_bits, lhs_signed = lhs_info
    rhs_bits, rhs_signed = rhs_info
    if rhs_bits > lhs_bits:
        # Narrowing conversion — check if value can actually overflow
        rhs_interval = get_token_interval(rhs)
        lhs_min, lhs_max = type_range(lhs_bits, lhs_signed)
        if rhs_interval is not None:
            if rhs_interval.can_exceed(lhs_max) or rhs_interval.can_be_below(lhs_min):
                report_finding(@eq, 'warning',
                    f\"Truncation: assigning {rhs_bits}-bit value (range [{rhs_interval.lo}, {rhs_interval.hi}]) \"
                    f\"to {lhs_bits}-bit {'signed' if lhs_signed else 'unsigned'} variable \"
                    f\"(range [{lhs_min}, {lhs_max}])\",
                    192)
        else:
            # No value info — report as portability concern
            report_finding(@eq, 'portability',
                f\"Possible truncation: {rhs_bits}-bit value assigned to {lhs_bits}-bit \"
                f\"{'signed' if lhs_signed else 'unsigned'} variable\",
                197)
")))

  ;; Rule TR-2: Explicit narrowing cast
  (rule narrowing-cast
    (description "Detect narrowing in explicit cast expressions.")
    (match
      (token @cast)
      (constraint (python-pred
        "@cast.str == '(' and getattr(@cast, 'isCast', False) and "
        "getattr(@cast, 'astOperand1', None) is not None")))
    (action
      (python-block "
# The cast token itself has the destination type, operand1 is the source expression
src = @cast.astOperand1
dst_info = get_type_info_token(@cast)
src_info = get_type_info_token(src)
if dst_info and src_info:
    dst_bits, dst_signed = dst_info
    src_bits, src_signed = src_info
    if src_bits > dst_bits:
        src_interval = get_token_interval(src)
        dst_min, dst_max = type_range(dst_bits, dst_signed)
        if src_interval is not None and (src_interval.can_exceed(dst_max) or src_interval.can_be_below(dst_min)):
            report_finding(@cast, 'warning',
                f\"Truncation in cast: {src_bits}-bit value (range [{src_interval.lo}, {src_interval.hi}]) \"
                f\"cast to {dst_bits}-bit {'signed' if dst_signed else 'unsigned'} type \"
                f\"(range [{dst_min}, {dst_max}])\",
                192)
        elif src_interval is None:
            report_finding(@cast, 'portability',
                f\"Possible truncation in cast: {src_bits}-bit to {dst_bits}-bit \"
                f\"{'signed' if dst_signed else 'unsigned'}\",
                197)
")))

  ;; Rule TR-3: Narrowing in function return
  (rule narrowing-return
    (description "Detect narrowing when a wider expression is returned from a function with a narrower return type.")
    (match
      (token @ret)
      (constraint (python-pred
        "@ret.str == 'return' and "
        "@ret.next is not None and "
        "@ret.next.str != ';'")))
    (action
      (python-block "
# Find the return expression's type and the function's return type
ret_expr = getattr(@ret, 'astOperand1', None)
if ret_expr is None:
    ret_expr = @ret.next  # fallback
if ret_expr is not None:
    expr_info = get_type_info_token(ret_expr)
    if expr_info:
        func_scope = get_enclosing_function(@ret)
        if func_scope and getattr(func_scope, 'function', None):
            fn = func_scope.function
            fn_tok = getattr(fn, 'tokenDef', None) or getattr(fn, 'token', None)
            if fn_tok:
                ret_type_tok = getattr(fn, 'tokenDef', fn_tok)
                # Walk backwards from function name to find return type tokens
                t = getattr(ret_type_tok, 'previous', None)
                if t:
                    ret_info = get_type_info_token(t)
                    if ret_info:
                        ret_bits, ret_signed = ret_info
                        expr_bits, expr_signed = expr_info
                        if expr_bits > ret_bits:
                            report_finding(@ret, 'portability',
                                f\"Possible truncation in return: {expr_bits}-bit expression \"
                                f\"returned as {ret_bits}-bit type\",
                                197)
")))
)

;; ═════════════════════════════════════════════════════════════════════
;;  PASS 4: SIGN CONVERSION CHECK  (CWE-194, 195, 196, 681)
;;
;;  Detects hazardous conversions between signed and unsigned types.
;; ═════════════════════════════════════════════════════════════════════

(pass sign-conversion
  (description "Detect dangerous signed/unsigned conversions (CWE-194, 195, 196, 681).")
  (strategy linear-forward)
  (order 3)

  ;; Rule SC-1: Signed to unsigned assignment (negative value possible)
  (rule signed-to-unsigned-assign
    (description "Detect assignment of a potentially negative signed value to an unsigned variable (CWE-195).")
    (match
      (token @eq)
      (constraint (python-pred
        "@eq.str == '=' and "
        "getattr(@eq, 'astOperand1', None) is not None and "
        "getattr(@eq, 'astOperand2', None) is not None")))
    (action
      (python-block "
lhs = @eq.astOperand1
rhs = @eq.astOperand2
lhs_info = get_type_info_token(lhs)
rhs_info = get_type_info_token(rhs)
if lhs_info and rhs_info:
    lhs_bits, lhs_signed = lhs_info
    rhs_bits, rhs_signed = rhs_info
    if rhs_signed and not lhs_signed:
        rhs_iv = get_token_interval(rhs)
        if rhs_iv is not None and rhs_iv.can_be_negative():
            report_finding(@eq, 'warning',
                f\"Signed to unsigned conversion: signed value (range [{rhs_iv.lo}, {rhs_iv.hi}]) \"
                f\"assigned to unsigned {lhs_bits}-bit variable; negative values will wrap\",
                195)
        elif rhs_iv is None:
            report_finding(@eq, 'portability',
                f\"Signed to unsigned conversion: signed {rhs_bits}-bit value \"
                f\"assigned to unsigned {lhs_bits}-bit variable\",
                195)
")))

  ;; Rule SC-2: Unsigned to signed assignment (large value possible)
  (rule unsigned-to-signed-assign
    (description "Detect assignment of a potentially large unsigned value to a signed variable (CWE-194).")
    (match
      (token @eq)
      (constraint (python-pred
        "@eq.str == '=' and "
        "getattr(@eq, 'astOperand1', None) is not None and "
        "getattr(@eq, 'astOperand2', None) is not None")))
    (action
      (python-block "
lhs = @eq.astOperand1
rhs = @eq.astOperand2
lhs_info = get_type_info_token(lhs)
rhs_info = get_type_info_token(rhs)
if lhs_info and rhs_info:
    lhs_bits, lhs_signed = lhs_info
    rhs_bits, rhs_signed = rhs_info
    if not rhs_signed and lhs_signed:
        rhs_iv = get_token_interval(rhs)
        lhs_max = (1 << (lhs_bits - 1)) - 1
        if rhs_iv is not None and rhs_iv.can_exceed(lhs_max):
            report_finding(@eq, 'warning',
                f\"Unsigned to signed conversion: unsigned value (range [{rhs_iv.lo}, {rhs_iv.hi}]) \"
                f\"assigned to signed {lhs_bits}-bit variable; values > {lhs_max} will be negative\",
                194)
        elif rhs_iv is None and rhs_bits >= lhs_bits:
            report_finding(@eq, 'portability',
                f\"Unsigned to signed conversion: unsigned {rhs_bits}-bit value \"
                f\"assigned to signed {lhs_bits}-bit variable\",
                194)
")))

  ;; Rule SC-3: Sign change in cast
  (rule sign-change-cast
    (description "Detect explicit casts that change signedness (CWE-196, CWE-681).")
    (match
      (token @cast)
      (constraint (python-pred
        "@cast.str == '(' and getattr(@cast, 'isCast', False) and "
        "getattr(@cast, 'astOperand1', None) is not None")))
    (action
      (python-block "
src = @cast.astOperand1
dst_info = get_type_info_token(@cast)
src_info = get_type_info_token(src)
if dst_info and src_info:
    dst_bits, dst_signed = dst_info
    src_bits, src_signed = src_info
    if src_signed != dst_signed:
        src_iv = get_token_interval(src)
        if src_signed and not dst_signed:
            # signed -> unsigned cast
            if src_iv and src_iv.can_be_negative():
                report_finding(@cast, 'warning',
                    f\"Sign change in cast: signed value (can be negative) cast to unsigned {dst_bits}-bit type\",
                    196)
            elif src_iv is None:
                report_finding(@cast, 'portability',
                    f\"Sign change in cast: signed {src_bits}-bit cast to unsigned {dst_bits}-bit\",
                    681)
        else:
            # unsigned -> signed cast
            dst_max = (1 << (dst_bits - 1)) - 1
            if src_iv and src_iv.can_exceed(dst_max):
                report_finding(@cast, 'warning',
                    f\"Sign change in cast: unsigned value (can exceed {dst_max}) cast to signed {dst_bits}-bit type\",
                    196)
            elif src_iv is None:
                report_finding(@cast, 'portability',
                    f\"Sign change in cast: unsigned {src_bits}-bit cast to signed {dst_bits}-bit\",
                    681)
")))

  ;; Rule SC-4: Negative value used as array index
  (rule negative-array-index
    (description "Detect potentially negative values used as array indices (CWE-194).")
    (match
      (token @bracket)
      (constraint (python-pred
        "@bracket.str == '[' and "
        "getattr(@bracket, 'astOperand2', None) is not None")))
    (action
      (python-block "
idx = @bracket.astOperand2
idx_info = get_type_info_token(idx)
if idx_info and idx_info[1]:  # signed index
    idx_iv = get_token_interval(idx)
    if idx_iv is not None and idx_iv.can_be_negative():
        report_finding(@bracket, 'warning',
            f\"Potentially negative array index: signed index (range [{idx_iv.lo}, {idx_iv.hi}])\",
            194)
")))
)

;; ═════════════════════════════════════════════════════════════════════
;;  PASS 5: OFF-BY-ONE CHECK  (CWE-193)
;;
;;  Detects common off-by-one error patterns:
;;   - Loop with <= instead of < for array bounds
;;   - malloc(strlen(s)) missing +1 for NUL
;;   - buf[sizeof(buf)] — accessing one past the end
;; ═════════════════════════════════════════════════════════════════════

(pass off-by-one
  (description "Detect off-by-one errors (CWE-193) in loops, allocations, and array accesses.")
  (strategy linear-forward)
  (order 4)

  ;; Rule OBO-1: Loop bound uses <= with array size
  (rule loop-lte-array-size
    (description "Detect 'i <= N' loop condition where N is an array size (should be 'i < N').")
    (match
      (token @cmp)
      (constraint (python-pred
        "@cmp.str == '<=' and "
        "getattr(@cmp, 'astOperand1', None) is not None and "
        "getattr(@cmp, 'astOperand2', None) is not None and "
        "getattr(@cmp, 'scope', None) is not None and "
        "getattr(@cmp.scope, 'type', '') in ('For', 'While')")))
    (action
      (python-block "
rhs = @cmp.astOperand2
# Check if RHS is sizeof(arr)/sizeof(arr[0]) or a known array dimension
rhs_str = getattr(rhs, 'str', '')
# Pattern: i <= sizeof(buf) or i <= ARRAY_SIZE
if rhs_str == 'sizeof' or (rhs and getattr(rhs, 'variable', None) and
                            getattr(rhs.variable, 'isArray', False)):
    report_finding(@cmp, 'warning',
        f\"Off-by-one: loop condition uses '<=' with array bound; consider '<'\",
        193)
# Pattern: i <= strlen(s)
if rhs_str == '(' and getattr(rhs, 'astOperand1', None):
    fn = rhs.astOperand1
    if getattr(fn, 'str', '') == 'strlen':
        report_finding(@cmp, 'warning',
            f\"Off-by-one: loop uses '<= strlen(...)'; if writing, NUL terminator may be overwritten\",
            193)
# Check via value: rhs is literal array size
rhs_iv = get_token_interval(rhs)
lhs = @cmp.astOperand1
if lhs and rhs_iv and getattr(lhs, 'variable', None):
    # If the loop var is used as array index, and rhs equals array dim, flag it
    var = lhs.variable
    scope = @cmp.scope
    if scope:
        # Scan loop body for array access with this variable
        t = getattr(scope, 'bodyStart', None)
        end = getattr(scope, 'bodyEnd', None)
        if t and end:
            t = t.next
            while t and t != end:
                if t.str == '[' and getattr(t, 'astOperand2', None):
                    idx = t.astOperand2
                    if getattr(idx, 'varId', None) == getattr(lhs, 'varId', None):
                        report_finding(@cmp, 'warning',
                            f\"Off-by-one: loop variable used as array index with '<=' bound\",
                            193)
                        break
                t = t.next
")))

  ;; Rule OBO-2: malloc(strlen(s)) — missing +1 for NUL terminator
  (rule malloc-strlen-no-plus-one
    (description "Detect malloc(strlen(s)) without +1 for the NUL terminator.")
    (match
      (token @call)
      (constraint (python-pred
        "@call.str == '(' and "
        "getattr(@call, 'astOperand1', None) is not None and "
        "getattr(@call.astOperand1, 'str', '') in ('malloc', 'calloc', 'realloc')")))
    (action
      (python-block "
fn_name = @call.astOperand1.str
# Look for strlen() in the argument subtree
arg = getattr(@call, 'astOperand2', None)
if arg is None:
    pass  # no arg
else:
    has_strlen = False
    has_plus_one = False
    for t in expr_tokens(arg):
        if getattr(t, 'str', '') == 'strlen':
            has_strlen = True
        if t.str == '+':
            # Check if one operand is 1
            o1 = getattr(t, 'astOperand1', None)
            o2 = getattr(t, 'astOperand2', None)
            if (o1 and getattr(o1, 'str', '') == '1') or (o2 and getattr(o2, 'str', '') == '1'):
                has_plus_one = True
    if has_strlen and not has_plus_one:
        report_finding(@call, 'warning',
            f\"{fn_name}(strlen(...)) without +1: no space for NUL terminator\",
            193)
")))

  ;; Rule OBO-3: buf[sizeof(buf)] — access exactly at array size
  (rule access-at-sizeof
    (description "Detect array access at buf[sizeof(buf)] which is one past the end.")
    (match
      (token @bracket)
      (constraint (python-pred
        "@bracket.str == '[' and "
        "getattr(@bracket, 'astOperand1', None) is not None and "
        "getattr(@bracket, 'astOperand2', None) is not None")))
    (action
      (python-block "
arr = @bracket.astOperand1
idx = @bracket.astOperand2
# Pattern: buf[sizeof(buf)]
if getattr(idx, 'str', '') == 'sizeof':
    sizeof_arg = getattr(idx, 'astOperand2', None) or getattr(idx, 'astOperand1', None)
    if sizeof_arg and getattr(sizeof_arg, 'varId', None) == getattr(arr, 'varId', None):
        report_finding(@bracket, 'warning',
            f\"Off-by-one: accessing '{arr.str}[sizeof({arr.str})]' which is one past the end\",
            193)
# Pattern: buf[N] where N is the declared array dimension
if arr and getattr(arr, 'variable', None) and getattr(arr.variable, 'isArray', False):
    idx_iv = get_token_interval(idx)
    if idx_iv is not None:
        # Try to find array dimension from variable's type tokens
        dim_tok = getattr(arr.variable, 'nameToken', None)
        if dim_tok:
            t = dim_tok.next
            if t and t.str == '[':
                dim_expr = t.next
                if dim_expr and getattr(dim_expr, 'isNumber', False):
                    try:
                        dim = int(dim_expr.str)
                        if idx_iv.contains(dim):
                            report_finding(@bracket, 'warning',
                                f\"Off-by-one: array '{arr.str}' has {dim} elements but index can be {dim}\",
                                193)
                    except ValueError:
                        pass
")))
)

;; ═════════════════════════════════════════════════════════════════════
;;  PASS 6: ALLOCATION OVERFLOW CHECK  (CWE-128, CWE-190)
;;
;;  Detects multiplication overflow in allocation size arguments.
;;  Example:  malloc(count * size)  where count * size can wrap.
;; ═════════════════════════════════════════════════════════════════════

(pass allocation-overflow
  (description "Detect multiplication overflow in allocation size expressions (CWE-128).")
  (strategy linear-forward)
  (order 5)

  ;; Rule AO-1: Multiplication in allocation argument
  (rule alloc-mul-overflow
    (description "Detect unchecked multiplication in malloc/calloc/realloc argument that may wrap around.")
    (match
      (token @call)
      (constraint (python-pred
        "@call.str == '(' and "
        "getattr(@call, 'astOperand1', None) is not None and "
        "getattr(@call.astOperand1, 'str', '') in ('malloc', 'realloc', 'calloc', 'aligned_alloc')")))
    (action
      (python-block "
fn_name = @call.astOperand1.str
arg = getattr(@call, 'astOperand2', None)
if arg is None:
    pass
else:
    # For calloc, skip — calloc(count, size) handles overflow internally on many platforms
    if fn_name == 'calloc':
        pass
    else:
        # Find multiplication nodes in the argument expression
        for t in expr_tokens(arg):
            if t.str == '*':
                op1 = getattr(t, 'astOperand1', None)
                op2 = getattr(t, 'astOperand2', None)
                if op1 and op2:
                    iv1 = get_token_interval(op1)
                    iv2 = get_token_interval(op2)
                    if iv1 and iv2:
                        result = iv1.mul(iv2)
                        # size_t is 64-bit unsigned on LP64
                        size_t_max = (1 << 64) - 1
                        if result.can_exceed(size_t_max):
                            report_finding(t, 'warning',
                                f\"Allocation size overflow: {fn_name}() argument contains \"
                                f\"multiplication that can exceed SIZE_MAX ({size_t_max})\",
                                128)
                    elif iv1 is None and iv2 is None:
                        # Both unknown — could be user-controlled, flag as potential issue
                        # Only flag if neither operand is a small constant
                        o1_const = interval_from_number(op1)
                        o2_const = interval_from_number(op2)
                        if not o1_const and not o2_const:
                            report_finding(t, 'warning',
                                f\"Potential allocation size overflow: {fn_name}() argument has \"
                                f\"unchecked multiplication of non-constant values\",
                                128)
                    break  # report at most once per allocation
")))

  ;; Rule AO-2: Left-shift in allocation argument
  (rule alloc-shift-overflow
    (description "Detect left-shift in allocation size that may overflow.")
    (match
      (token @call)
      (constraint (python-pred
        "@call.str == '(' and "
        "getattr(@call, 'astOperand1', None) is not None and "
        "getattr(@call.astOperand1, 'str', '') in ('malloc', 'realloc')")))
    (action
      (python-block "
fn_name = @call.astOperand1.str
arg = getattr(@call, 'astOperand2', None)
if arg:
    for t in expr_tokens(arg):
        if t.str == '<<':
            op1 = getattr(t, 'astOperand1', None)
            op2 = getattr(t, 'astOperand2', None)
            if op1 and op2:
                iv1 = get_token_interval(op1)
                iv2 = get_token_interval(op2)
                if iv1 and iv2:
                    result = iv1.lshift(iv2)
                    if result.is_top() or result.can_exceed((1 << 64) - 1):
                        report_finding(t, 'warning',
                            f\"Allocation size overflow: {fn_name}() argument contains \"
                            f\"left-shift that may overflow\",
                            128)
            break
")))
)

;; ═════════════════════════════════════════════════════════════════════
;;  PASS 7: MIXED-SIGN COMPARISON CHECK  (CWE-681)
;;
;;  Flags comparison operators (<, <=, >, >=, ==, !=) where one
;;  operand is signed and the other unsigned. Implicit conversion
;;  rules in C can make the comparison produce unexpected results.
;; ═════════════════════════════════════════════════════════════════════

(pass mixed-sign-comparison
  (description "Detect comparisons between signed and unsigned integers (CWE-681).")
  (strategy linear-forward)
  (order 6)

  ;; Rule MSC-1: Mixed-sign comparison
  (rule mixed-sign-cmp
    (description "Flag comparison where one operand is signed and the other is unsigned.")
    (match
      (token @cmp)
      (constraint (python-pred
        "@cmp.str in ('<', '<=', '>', '>=', '==', '!=') and "
        "getattr(@cmp, 'astOperand1', None) is not None and "
        "getattr(@cmp, 'astOperand2', None) is not None and "
        "getattr(@cmp, 'isComparisonOp', False)")))
    (action
      (python-block "
op1 = @cmp.astOperand1
op2 = @cmp.astOperand2
info1 = get_type_info_token(op1)
info2 = get_type_info_token(op2)
if info1 and info2:
    bits1, signed1 = info1
    bits2, signed2 = info2
    if signed1 != signed2:
        # Determine which is signed and which is unsigned
        if signed1:
            signed_op, unsigned_op = op1, op2
            signed_bits, unsigned_bits = bits1, bits2
        else:
            signed_op, unsigned_op = op2, op1
            signed_bits, unsigned_bits = bits2, bits1
        # Check if the signed operand can be negative
        signed_iv = get_token_interval(signed_op)
        if signed_iv is not None and signed_iv.can_be_negative():
            report_finding(@cmp, 'warning',
                f\"Mixed-sign comparison: signed {signed_bits}-bit value \"
                f\"(can be negative, range [{signed_iv.lo}, {signed_iv.hi}]) compared with \"
                f\"unsigned {unsigned_bits}-bit value. Implicit conversion may reverse the comparison result.\",
                681)
        elif signed_iv is None:
            report_finding(@cmp, 'portability',
                f\"Mixed-sign comparison: signed {signed_bits}-bit compared with \"
                f\"unsigned {unsigned_bits}-bit value\",
                681)
")))

  ;; Rule MSC-2: Signed variable compared against unsigned constant 0
  ;;             This is actually fine (comparison with 0 is always safe),
  ;;             so we suppress it via an exception rule.
  (rule suppress-cmp-zero
    (description "Suppress mixed-sign comparison when one operand is the literal 0 (always safe).")
    (match
      (token @cmp)
      (constraint (python-pred
        "@cmp.str in ('<', '<=', '>', '>=', '==', '!=') and "
        "getattr(@cmp, 'isComparisonOp', False) and "
        "((getattr(@cmp.astOperand1, 'str', '') == '0') or "
        " (getattr(@cmp.astOperand2, 'str', '') == '0'))")))
    (action
      (suppress @cmp "mixed-sign-cmp-zero")))
)

;; ═════════════════════════════════════════════════════════════════════
;;  PASS 8: SHIFT OVERFLOW CHECK  (CWE-190)
;;
;;  Detects undefined or dangerous shift operations:
;;   - Shift amount >= bit-width of the type
;;   - Negative shift amount
;;   - Left-shift of a negative signed value (UB in C)
;; ═════════════════════════════════════════════════════════════════════

(pass shift-overflow
  (description "Detect undefined and dangerous shift operations (CWE-190).")
  (strategy linear-forward)
  (order 7)

  ;; Rule SH-1: Shift amount exceeds or equals bit-width
  (rule shift-amount-too-large
    (description "Detect shift where the amount >= bit-width of the left operand's type (undefined behavior).")
    (match
      (token @shift)
      (constraint (python-pred
        "@shift.str in ('<<', '>>') and "
        "getattr(@shift, 'astOperand1', None) is not None and "
        "getattr(@shift, 'astOperand2', None) is not None")))
    (action
      (python-block "
lhs = @shift.astOperand1
rhs = @shift.astOperand2
lhs_info = get_type_info_token(lhs)
if lhs_info:
    bits, signed = lhs_info
    rhs_iv = get_token_interval(rhs)
    if rhs_iv is not None:
        if rhs_iv.lo >= bits:
            report_finding(@shift, 'error',
                f\"Undefined behavior: shift amount [{rhs_iv.lo}, {rhs_iv.hi}] \"
                f\">= type width ({bits} bits)\",
                190)
        elif rhs_iv.can_exceed(bits - 1):
            report_finding(@shift, 'warning',
                f\"Shift amount (range [{rhs_iv.lo}, {rhs_iv.hi}]) may exceed \"
                f\"type width ({bits} bits) — undefined behavior\",
                190)
")))

  ;; Rule SH-2: Negative shift amount
  (rule negative-shift-amount
    (description "Detect shift where the amount can be negative (undefined behavior).")
    (match
      (token @shift)
      (constraint (python-pred
        "@shift.str in ('<<', '>>') and "
        "getattr(@shift, 'astOperand2', None) is not None")))
    (action
      (python-block "
rhs = @shift.astOperand2
rhs_info = get_type_info_token(rhs)
if rhs_info and rhs_info[1]:  # signed shift amount
    rhs_iv = get_token_interval(rhs)
    if rhs_iv is not None and rhs_iv.can_be_negative():
        report_finding(@shift, 'error',
            f\"Undefined behavior: shift amount can be negative \"
            f\"(range [{rhs_iv.lo}, {rhs_iv.hi}])\",
            190)
")))

  ;; Rule SH-3: Left-shift of negative signed value
  (rule lshift-negative-value
    (description "Detect left-shift of a negative signed value (undefined behavior in C).")
    (match
      (token @shift)
      (constraint (python-pred
        "@shift.str == '<<' and "
        "getattr(@shift, 'astOperand1', None) is not None")))
    (action
      (python-block "
lhs = @shift.astOperand1
lhs_info = get_type_info_token(lhs)
if lhs_info and lhs_info[1]:  # signed left operand
    lhs_iv = get_token_interval(lhs)
    if lhs_iv is not None and lhs_iv.can_be_negative():
        report_finding(@shift, 'warning',
            f\"Left-shift of possibly negative signed value \"
            f\"(range [{lhs_iv.lo}, {lhs_iv.hi}]) — undefined behavior in C\",
            190)
")))

  ;; Rule SH-4: Shift into sign bit (signed left-shift overflow)
  (rule shift-into-sign-bit
    (description "Detect left-shift where the result may set or overflow the sign bit of a signed type.")
    (match
      (token @shift)
      (constraint (python-pred
        "@shift.str == '<<' and "
        "getattr(@shift, 'astOperand1', None) is not None and "
        "getattr(@shift, 'astOperand2', None) is not None")))
    (action
      (python-block "
lhs = @shift.astOperand1
rhs = @shift.astOperand2
lhs_info = get_type_info_token(lhs)
if lhs_info:
    bits, signed = lhs_info
    if signed:
        lhs_iv = get_token_interval(lhs)
        rhs_iv = get_token_interval(rhs)
        if lhs_iv and rhs_iv and not lhs_iv.can_be_negative():
            # For positive values, check if lhs << rhs can exceed SIGNED_MAX
            result = lhs_iv.lshift(rhs_iv)
            smax = (1 << (bits - 1)) - 1
            if not result.is_top() and result.can_exceed(smax):
                report_finding(@shift, 'warning',
                    f\"Left-shift overflow: result of signed shift may exceed \"
                    f\"{smax} ({bits}-bit signed max), which is undefined behavior\",
                    190)
")))
)

;; ═════════════════════════════════════════════════════════════════════
;;  ENTRY POINT
;;
;;  Standard CASL entry point block — handles argument parsing,
;;  dump file loading, and pass execution.
;; ═════════════════════════════════════════════════════════════════════

(entry-point
  (description "Main entry point for the IntegerLint addon.")
  (argument-parser cppcheckdata)
  (pass-order
    value-tracker
    overflow-underflow
    truncation
    sign-conversion
    off-by-one
    allocation-overflow
    mixed-sign-comparison
    shift-overflow))

;; ═════════════════════════════════════════════════════════════════════
;;  TEST SUITE
;;
;;  Embedded test specifications that can be extracted by the CASL
;;  test harness to validate the generated addon.
;; ═════════════════════════════════════════════════════════════════════

(test-suite
  (description "Comprehensive test suite for IntegerLint — 15 test programs covering all 10 CWEs.")

  ;; Test 1: CWE-190 — Integer overflow in addition
  (test-case test-overflow-add
    (description "Addition overflow of signed int.")
    (c-source "
#include <limits.h>
int test_overflow_add(void) {
    int a = INT_MAX;
    int b = a + 1;  /* BUG: overflow */
    return b;
}
")
    (expected-findings
      (finding (cwe 190) (severity warning) (line 4))))

  ;; Test 2: CWE-191 — Integer underflow in subtraction
  (test-case test-underflow-sub
    (description "Subtraction underflow of signed int.")
    (c-source "
#include <limits.h>
int test_underflow_sub(void) {
    int a = INT_MIN;
    int b = a - 1;  /* BUG: underflow */
    return b;
}
")
    (expected-findings
      (finding (cwe 191) (severity warning) (line 4))))

  ;; Test 3: CWE-190 — Multiplication overflow
  (test-case test-overflow-mul
    (description "Multiplication overflow of signed int.")
    (c-source "
int test_overflow_mul(int x) {
    int y = x * 1000000;  /* BUG: potential overflow if x > 2147 */
    return y;
}
")
    (expected-findings
      (finding (cwe 190) (severity warning) (line 3))))

  ;; Test 4: CWE-192 — Integer truncation (long to short)
  (test-case test-truncation
    (description "Narrowing assignment from long to short.")
    (c-source "
void test_truncation(void) {
    long big = 100000L;
    short small = big;  /* BUG: truncation */
}
")
    (expected-findings
      (finding (cwe 192) (severity warning) (line 4))))

  ;; Test 5: CWE-197 — Numeric truncation in cast
  (test-case test-truncation-cast
    (description "Explicit narrowing cast.")
    (c-source "
void test_truncation_cast(long val) {
    short s = (short)val;  /* BUG: truncation */
}
")
    (expected-findings
      (finding (cwe 197) (severity portability) (line 3))))

  ;; Test 6: CWE-195 — Signed to unsigned conversion
  (test-case test-signed-to-unsigned
    (description "Negative signed value assigned to unsigned.")
    (c-source "
#include <stddef.h>
void test_signed_to_unsigned(void) {
    int x = -1;
    unsigned int y = x;  /* BUG: -1 wraps to UINT_MAX */
}
")
    (expected-findings
      (finding (cwe 195) (severity warning) (line 5))))

  ;; Test 7: CWE-194 — Unsigned to signed conversion
  (test-case test-unsigned-to-signed
    (description "Large unsigned value assigned to signed (becomes negative).")
    (c-source "
void test_unsigned_to_signed(void) {
    unsigned int big = 3000000000U;
    int x = big;  /* BUG: exceeds INT_MAX */
}
")
    (expected-findings
      (finding (cwe 194) (severity warning) (line 4))))

  ;; Test 8: CWE-196 — Unsigned to signed in cast
  (test-case test-sign-cast
    (description "Sign-changing cast.")
    (c-source "
#include <stdint.h>
void test_sign_cast(void) {
    int8_t x = -5;
    uint8_t y = (uint8_t)x;  /* BUG: negative -> unsigned */
}
")
    (expected-findings
      (finding (cwe 196) (severity warning) (line 5))))

  ;; Test 9: CWE-193 — Off-by-one loop bound
  (test-case test-off-by-one-loop
    (description "Loop uses <= instead of < with array bound.")
    (c-source "
void test_off_by_one(void) {
    int buf[10];
    for (int i = 0; i <= 10; i++) {  /* BUG: should be < 10 */
        buf[i] = 0;
    }
}
")
    (expected-findings
      (finding (cwe 193) (severity warning) (line 4))))

  ;; Test 10: CWE-193 — malloc(strlen(s)) missing +1
  (test-case test-malloc-strlen
    (description "malloc(strlen(s)) without +1 for NUL.")
    (c-source "
#include <stdlib.h>
#include <string.h>
char* test_malloc_strlen(const char *s) {
    char *p = malloc(strlen(s));  /* BUG: missing +1 */
    return p;
}
")
    (expected-findings
      (finding (cwe 193) (severity warning) (line 5))))

  ;; Test 11: CWE-128 — Allocation size overflow
  (test-case test-alloc-overflow
    (description "Multiplication overflow in malloc() argument.")
    (c-source "
#include <stdlib.h>
void* test_alloc_overflow(size_t count, size_t size) {
    void *p = malloc(count * size);  /* BUG: unchecked multiplication */
    return p;
}
")
    (expected-findings
      (finding (cwe 128) (severity warning) (line 4))))

  ;; Test 12: CWE-681 — Mixed-sign comparison
  (test-case test-mixed-sign-cmp
    (description "Comparing signed and unsigned integers.")
    (c-source "
int test_mixed_cmp(int x, unsigned int y) {
    if (x < y) {  /* BUG: mixed-sign comparison */
        return 1;
    }
    return 0;
}
")
    (expected-findings
      (finding (cwe 681) (severity portability) (line 3))))

  ;; Test 13: CWE-190 — Shift amount too large
  (test-case test-shift-too-large
    (description "Shift amount >= bit-width.")
    (c-source "
int test_shift_large(int x) {
    return x << 32;  /* BUG: shift >= 32 for 32-bit int */
}
")
    (expected-findings
      (finding (cwe 190) (severity error) (line 3))))

  ;; Test 14: CWE-190 — Left-shift of negative value
  (test-case test-lshift-negative
    (description "Left-shift of a negative signed value (undefined behavior).")
    (c-source "
int test_lshift_neg(void) {
    int x = -1;
    return x << 4;  /* BUG: left-shift of negative value */
}
")
    (expected-findings
      (finding (cwe 190) (severity warning) (line 4))))

  ;; Test 15: CWE-193 — buf[sizeof(buf)]
  (test-case test-access-at-sizeof
    (description "Array access at sizeof(buf) — one past the end.")
    (c-source "
void test_access_sizeof(void) {
    char buf[64];
    buf[sizeof(buf)] = '\\0';  /* BUG: one past the end */
}
")
    (expected-findings
      (finding (cwe 193) (severity warning) (line 4))))
)

;; ═════════════════════════════════════════════════════════════════════
;;  END OF IntegerLint.casl
;; ═════════════════════════════════════════════════════════════════════
