;;;; ═══════════════════════════════════════════════════════════════════
;;;; format_string_validator.casl
;;;;
;;;; Declarative specification for detecting format-string
;;;; vulnerabilities and argument mismatches in C/C++ programs.
;;;;
;;;; Rules:
;;;;   FS01 — Missing arguments (fewer args than specifiers)
;;;;   FS02 — Extra arguments (more args than specifiers)
;;;;   FS03 — Type mismatch (arg type vs specifier)
;;;;   FS04 — Tainted/non-literal format string (CWE-134)
;;;;   FS05 — Invalid/unknown conversion specifier
;;;;   FS06 — %n usage (writes to memory)
;;;;   FS07 — Width/precision * with non-int argument
;;;;   FS08 — Scanf argument not a pointer
;;;; ═══════════════════════════════════════════════════════════════════

(spec format-string-validator
  :version "1.0.0"
  :language (C C++)
  :description "Detect format-string vulnerabilities and argument mismatches
                in printf/scanf-family function calls."
  :authors ("CASL Static Analysis Team")
  :references (
    "CWE-134: Use of Externally-Controlled Format String"
    "CERT C: FIO30-C, FIO47-C"
    "MISRA C:2012 Rule 17.1"
  ))


;;; ─────────────────────────────────────────────────────────────────────
;;; Format Function Database
;;;
;;; Each entry declares: function name, family (printf|scanf),
;;; 0-based index of the format-string parameter, 0-based index
;;; of the first variadic argument (-1 for va_list versions).
;;; ─────────────────────────────────────────────────────────────────────

(declare-format-functions
  ;; Printf family
  (printf      :family printf  :fmt-index 0  :va-index 1)
  (fprintf     :family printf  :fmt-index 1  :va-index 2)
  (sprintf     :family printf  :fmt-index 1  :va-index 2)
  (snprintf    :family printf  :fmt-index 2  :va-index 3)
  (dprintf     :family printf  :fmt-index 1  :va-index 2)
  (syslog      :family printf  :fmt-index 1  :va-index 2)
  (wprintf     :family printf  :fmt-index 0  :va-index 1)
  (fwprintf    :family printf  :fmt-index 1  :va-index 2)
  (swprintf    :family printf  :fmt-index 2  :va-index 3)
  ;; va_list versions (check format string only, not args)
  (vprintf     :family printf  :fmt-index 0  :va-index -1)
  (vfprintf    :family printf  :fmt-index 1  :va-index -1)
  (vsprintf    :family printf  :fmt-index 1  :va-index -1)
  (vsnprintf   :family printf  :fmt-index 2  :va-index -1)
  ;; Scanf family
  (scanf       :family scanf   :fmt-index 0  :va-index 1)
  (fscanf      :family scanf   :fmt-index 1  :va-index 2)
  (sscanf      :family scanf   :fmt-index 1  :va-index 2)
  (wscanf      :family scanf   :fmt-index 0  :va-index 1)
  (fwscanf     :family scanf   :fmt-index 1  :va-index 2)
  (swscanf     :family scanf   :fmt-index 1  :va-index 2)
  ;; va_list scanf
  (vscanf      :family scanf   :fmt-index 0  :va-index -1)
  (vfscanf     :family scanf   :fmt-index 1  :va-index -1)
  (vsscanf     :family scanf   :fmt-index 1  :va-index -1))


;;; ─────────────────────────────────────────────────────────────────────
;;; Taint Sources for FS04
;;; ─────────────────────────────────────────────────────────────────────

(declare-taint-sources
  argv getenv
  fgets gets read recv recvfrom recvmsg fread
  scanf fscanf getline getdelim)


;;; ─────────────────────────────────────────────────────────────────────
;;; Fact Schemas
;;; ─────────────────────────────────────────────────────────────────────

(fact-schema format-call
  "A call to a format-string function."
  :fields (
    (callee-name    :type string     :doc "Function name")
    (family         :type string     :doc "printf or scanf")
    (location       :type location)
    (fmt-string     :type (option string) :doc "Literal format string or nil")
    (fmt-is-literal :type bool       :doc "True if format arg is a direct literal")
    (fmt-arg-token  :type token      :doc "Token of the format argument")
    (arg-tokens     :type (list token) :doc "Tokens for variadic arguments")
    (arg-count      :type int        :doc "Number of variadic arguments supplied")
    (scope-id       :type int)
  )
  :persist per-function)

(fact-schema parsed-directive
  "A single format directive parsed from a format string."
  :fields (
    (call-location  :type location   :doc "Location of the enclosing call")
    (raw            :type string     :doc "Raw text e.g. %-10.5ld")
    (position       :type int        :doc "Char offset in format string")
    (conv-type      :type symbol     :doc "signed-int | unsigned-int | float | char | string | pointer | write-count | percent | invalid")
    (specifier      :type char       :doc "The conversion character")
    (length-mod     :type string     :doc "Length modifier (h, l, ll, etc.)")
    (args-consumed  :type int        :doc "Number of arguments consumed")
    (star-width     :type bool)
    (star-precision :type bool)
    (is-suppressed  :type bool       :doc "Scanf * suppression")
  )
  :persist per-function)

(fact-schema tainted-var
  "A variable influenced by external input."
  :fields (
    (var-id   :type int)
    (source   :type string :doc "Name of taint source")
  )
  :persist per-function)


;;; ─────────────────────────────────────────────────────────────────────
;;; Specifier Type Compatibility
;;;
;;; Maps (conversion-type, length-modifier) → set of acceptable C types.
;;; Uses variadic promotion rules (float→double, small-int→int).
;;; ─────────────────────────────────────────────────────────────────────

(define-type-map printf-expected-types
  :doc "Map format directive → acceptable argument types for printf."
  :entries (
    ;; %d / %i — signed integer
    ((signed-int "")    → (int uint bool char short))
    ((signed-int "hh")  → (char signed-char int))
    ((signed-int "h")   → (short int))
    ((signed-int "l")   → (long int))
    ((signed-int "ll")  → (long-long))
    ((signed-int "z")   → (size_t ssize_t long unsigned-long))
    ((signed-int "j")   → (intmax_t long-long))
    ((signed-int "t")   → (ptrdiff_t long int))

    ;; %u / %o / %x / %X — unsigned integer
    ((unsigned-int "")    → (uint int bool char unsigned-short))
    ((unsigned-int "hh")  → (unsigned-char char int uint))
    ((unsigned-int "h")   → (unsigned-short int uint))
    ((unsigned-int "l")   → (unsigned-long long))
    ((unsigned-int "ll")  → (unsigned-long-long long-long))
    ((unsigned-int "z")   → (size_t unsigned-long))
    ((unsigned-int "j")   → (uintmax_t unsigned-long-long))

    ;; %f / %e / %g / %a — floating point
    ((float "")   → (double float))   ;; float promoted to double in varargs
    ((float "L")  → (long-double))

    ;; %c — character
    ((char "")    → (int char unsigned-char uint))
    ((char "l")   → (int uint))   ;; wint_t

    ;; %s — string
    ((string "")  → (char-ptr void-ptr))
    ((string "l") → (wchar_t-ptr))

    ;; %p — pointer
    ((pointer "")  → (void-ptr pointer char-ptr))

    ;; %n — write count (all must be pointers)
    ((write-count "")   → (int-ptr pointer))
    ((write-count "hh") → (pointer))
    ((write-count "h")  → (pointer))
    ((write-count "l")  → (pointer))
    ((write-count "ll") → (pointer))
  ))

(define-type-map scanf-expected-types
  :doc "For scanf, all non-suppressed arguments must be pointers."
  :default (pointer void-ptr char-ptr int-ptr))


;;; ═══════════════════════════════════════════════════════════════════
;;; PHASE 1: Collect Format-Function Call Sites
;;; ═══════════════════════════════════════════════════════════════════

(rule FS-collect-calls
  :doc "Find all calls to format-string functions and extract metadata."
  :phase collect

  :pattern
    (ast-match (call ?callee ?args)
      :where (is-format-function ?callee))

  :action
    (let* ((info     (format-function-info (token-str ?callee)))
           (all-args (flatten-call-args ?args))
           (fmt-idx  (fmt-index info))
           (va-idx   (va-index info))
           (fmt-tok  (nth fmt-idx all-args))
           (fmt-str  (try-extract-string-literal fmt-tok))
           (va-args  (if (>= va-idx 0)
                         (drop va-idx all-args)
                         (list))))
      (set-fact format-call
        :callee-name    (token-str ?callee)
        :family         (family info)
        :location       (current-location)
        :fmt-string     fmt-str
        :fmt-is-literal (is-string-literal-token fmt-tok)
        :fmt-arg-token  fmt-tok
        :arg-tokens     va-args
        :arg-count      (length va-args)
        :scope-id       (current-scope-id))))


;;; ═══════════════════════════════════════════════════════════════════
;;; PHASE 2: Parse Format Strings into Directives
;;; ═══════════════════════════════════════════════════════════════════

(rule FS-parse-format-strings
  :doc "Parse each format string into individual directives."
  :phase transform
  :requires (FS-collect-calls)

  :pattern
    (fact-match format-call ?fc
      :where (not (nil? (fmt-string ?fc))))

  :action
    (for-each (directive <- (parse-format-string
                              (fmt-string ?fc)
                              (family ?fc)))
      (set-fact parsed-directive
        :call-location  (location ?fc)
        :raw            (directive-raw directive)
        :position       (directive-position directive)
        :conv-type      (directive-conv-type directive)
        :specifier      (directive-specifier directive)
        :length-mod     (directive-length-mod directive)
        :args-consumed  (directive-args-consumed directive)
        :star-width     (directive-star-width directive)
        :star-precision (directive-star-precision directive)
        :is-suppressed  (directive-is-suppressed directive))))


;;; ═══════════════════════════════════════════════════════════════════
;;; PHASE 3: Taint Analysis for FS04
;;; ═══════════════════════════════════════════════════════════════════

(rule FS-taint-sources
  :doc "Identify variables directly tainted by external input."
  :phase dataflow

  :pattern
    (or
      ;; x = taint_source(...)
      (ast-match (assign ?lhs (call ?callee ?args))
        :where (is-taint-source ?callee))
      ;; main(argc, argv) — argv is tainted
      (ast-match (param ?p)
        :where (= (token-str ?p) "argv")))

  :action
    (set-fact tainted-var
      :var-id (var-id (match-case
                        ((assign ?lhs _) ?lhs)
                        ((param ?p) ?p)))
      :source (match-case
                ((assign _ (call ?callee _)) (token-str ?callee))
                ((param ?p) "argv"))))

(rule FS-taint-propagation
  :doc "Propagate taint through assignments: x = y where y is tainted."
  :phase dataflow
  :requires (FS-taint-sources)
  :fixpoint #t

  :pattern
    (and
      (ast-match (assign ?lhs ?rhs))
      (or
        (fact-match tainted-var ?tv
          :where (= (var-id ?tv) (any-var-in-expr ?rhs)))
        ;; Taint through string operations
        (ast-match (assign ?lhs (call ?callee ?args))
          :where (member (token-str ?callee)
                         (strcpy strcat strncpy strncat sprintf snprintf))
          :where (any-arg-tainted ?args))))

  :constraint
    (not (fact-match tainted-var
           :where (= (var-id _) (var-id ?lhs))))

  :action
    (set-fact tainted-var
      :var-id (var-id ?lhs)
      :source "propagation"))


;;; ═══════════════════════════════════════════════════════════════════
;;; RULE FS01 — Missing Arguments
;;; ═══════════════════════════════════════════════════════════════════

(rule FS01-report
  :doc "Report when fewer arguments are supplied than the format string requires."
  :phase report
  :requires (FS-collect-calls FS-parse-format-strings)

  :pattern
    (fact-match format-call ?fc
      :where (not (nil? (fmt-string ?fc)))
      :where (>= (va-index (format-function-info (callee-name ?fc))) 0))

  :constraint
    (let ((expected (sum (args-consumed d)
                     :for-each (d <- (directives-for ?fc)))))
      (< (arg-count ?fc) expected))

  :action
    (let ((expected (sum (args-consumed d)
                     :for-each (d <- (directives-for ?fc)))))
      (report
        :id       "formatString.FS01"
        :severity error
        :location (location ?fc)
        :message  (format
          "'~a' format string \"~a\" requires ~a argument(s) but only ~a supplied — undefined behaviour"
          (callee-name ?fc) (fmt-string ?fc) expected (arg-count ?fc)))))


;;; ═══════════════════════════════════════════════════════════════════
;;; RULE FS02 — Extra Arguments
;;; ═══════════════════════════════════════════════════════════════════

(rule FS02-report
  :doc "Report when more arguments are supplied than specifiers demand."
  :phase report
  :requires (FS-collect-calls FS-parse-format-strings)

  :pattern
    (fact-match format-call ?fc
      :where (not (nil? (fmt-string ?fc)))
      :where (>= (va-index (format-function-info (callee-name ?fc))) 0))

  :constraint
    (let ((expected (sum (args-consumed d)
                     :for-each (d <- (directives-for ?fc)))))
      (> (arg-count ?fc) expected))

  :action
    (let ((expected (sum (args-consumed d)
                     :for-each (d <- (directives-for ?fc)))))
      (report
        :id       "formatString.FS02"
        :severity warning
        :location (location ?fc)
        :message  (format
          "'~a' format string \"~a\" expects ~a argument(s) but ~a supplied — extra arguments ignored"
          (callee-name ?fc) (fmt-string ?fc) expected (arg-count ?fc)))))


;;; ═══════════════════════════════════════════════════════════════════
;;; RULE FS03 — Type Mismatch
;;; ═══════════════════════════════════════════════════════════════════

(rule FS03-report
  :doc "Report when an argument's type is incompatible with its specifier."
  :phase report
  :requires (FS-collect-calls FS-parse-format-strings)

  :pattern
    (and
      (fact-match format-call ?fc
        :where (not (nil? (fmt-string ?fc)))
        :where (>= (va-index (format-function-info (callee-name ?fc))) 0))
      (fact-match parsed-directive ?pd
        :where (= (call-location ?pd) (location ?fc))
        :where (not (= (conv-type ?pd) 'percent))
        :where (not (is-suppressed ?pd))))

  :constraint
    (let* ((arg-index  (compute-arg-index ?fc ?pd))
           (arg-tok    (nth arg-index (arg-tokens ?fc)))
           (actual     (resolve-type arg-tok))
           (expected   (lookup-type-map
                         (if (= (family ?fc) "printf")
                             printf-expected-types
                             scanf-expected-types)
                         (conv-type ?pd)
                         (length-mod ?pd))))
      (and
        (not (= actual 'unknown))
        (not (type-compatible actual expected))))

  :action
    (let* ((arg-index  (compute-arg-index ?fc ?pd))
           (actual     (resolve-type (nth arg-index (arg-tokens ?fc))))
           (expected   (lookup-type-map
                         (if (= (family ?fc) "printf")
                             printf-expected-types
                             scanf-expected-types)
                         (conv-type ?pd)
                         (length-mod ?pd))))
      (report
        :id       "formatString.FS03"
        :severity error
        :location (location ?fc)
        :message  (format
          "argument ~a to '~a' has type '~a' but format specifier '~a' expects ~a"
          (+ arg-index 1)
          (callee-name ?fc)
          actual
          (raw ?pd)
          (join " or " (map quote-type expected))))))


;;; ═══════════════════════════════════════════════════════════════════
;;; RULE FS04 — Non-literal / Tainted Format String
;;; ═══════════════════════════════════════════════════════════════════

(rule FS04-non-literal
  :doc "Report when the format argument is not a string literal."
  :phase report
  :requires (FS-collect-calls)

  :pattern
    (fact-match format-call ?fc
      :where (nil? (fmt-string ?fc)))

  :action
    (report
      :id       "formatString.FS04"
      :severity error
      :location (location ?fc)
      :message  (format
        "format string argument to '~a' is not a string literal — potential format string vulnerability (CWE-134)"
        (callee-name ?fc))
      :cwe 134))

(rule FS04-tainted
  :doc "Report when the format argument is tainted by external input."
  :phase report
  :requires (FS-collect-calls FS-taint-propagation)

  :pattern
    (and
      (fact-match format-call ?fc
        :where (not (fmt-is-literal ?fc)))
      (fact-match tainted-var ?tv
        :where (= (var-id ?tv)
                   (any-var-in-expr (fmt-arg-token ?fc)))))

  :action
    (report
      :id       "formatString.FS04"
      :severity error
      :location (location ?fc)
      :message  (format
        "TAINTED format string passed to '~a' — format argument may be influenced by external input via '~a' (CWE-134)"
        (callee-name ?fc)
        (source ?tv))
      :cwe 134))


;;; ═══════════════════════════════════════════════════════════════════
;;; RULE FS05 — Invalid/Unknown Specifier
;;; ═══════════════════════════════════════════════════════════════════

(rule FS05-report
  :doc "Report invalid or unrecognised conversion specifiers."
  :phase report
  :requires (FS-parse-format-strings)

  :pattern
    (fact-match parsed-directive ?pd
      :where (= (conv-type ?pd) 'invalid))

  :action
    (report
      :id       "formatString.FS05"
      :severity error
      :location (call-location ?pd)
      :message  (format
        "invalid format specifier '~a' at position ~a in format string"
        (raw ?pd)
        (position ?pd))))


;;; ═══════════════════════════════════════════════════════════════════
;;; RULE FS06 — %n Usage
;;; ═══════════════════════════════════════════════════════════════════

(rule FS06-report
  :doc "Report use of %n which writes to memory."
  :phase report
  :requires (FS-parse-format-strings)

  :pattern
    (fact-match parsed-directive ?pd
      :where (= (conv-type ?pd) 'write-count))

  :action
    (report
      :id       "formatString.FS06"
      :severity warning
      :location (call-location ?pd)
      :message  (format
        "use of '%n' — '%n' writes to memory and is a common attack vector (CWE-134)")
      :cwe 134))


;;; ═══════════════════════════════════════════════════════════════════
;;; RULE FS07 — Width/Precision * Type Mismatch
;;; ═══════════════════════════════════════════════════════════════════

(rule FS07-report
  :doc "Report when * width or precision receives a non-int argument."
  :phase report
  :requires (FS-collect-calls FS-parse-format-strings)

  :pattern
    (and
      (fact-match format-call ?fc
        :where (>= (va-index (format-function-info (callee-name ?fc))) 0))
      (fact-match parsed-directive ?pd
        :where (= (call-location ?pd) (location ?fc))
        :where (or (star-width ?pd) (star-precision ?pd))))

  :constraint
    (let* ((star-idx (compute-star-arg-index ?fc ?pd))
           (arg-tok  (nth star-idx (arg-tokens ?fc)))
           (actual   (resolve-type arg-tok)))
      (and
        (not (= actual 'unknown))
        (not (= actual 'int))))

  :action
    (let* ((star-idx (compute-star-arg-index ?fc ?pd))
           (actual   (resolve-type (nth star-idx (arg-tokens ?fc))))
           (which    (if (star-width ?pd) "width" "precision")))
      (report
        :id       "formatString.FS07"
        :severity style
        :location (location ?fc)
        :message  (format
          "'*' ~a in '~a' expects 'int' argument but got '~a'"
          which (raw ?pd) actual))))


;;; ═══════════════════════════════════════════════════════════════════
;;; RULE FS08 — Scanf Argument Not a Pointer
;;; ═══════════════════════════════════════════════════════════════════

(rule FS08-report
  :doc "Report when a scanf argument is not a pointer type."
  :phase report
  :requires (FS-collect-calls FS-parse-format-strings)

  :pattern
    (and
      (fact-match format-call ?fc
        :where (= (family ?fc) "scanf")
        :where (>= (va-index (format-function-info (callee-name ?fc))) 0))
      (fact-match parsed-directive ?pd
        :where (= (call-location ?pd) (location ?fc))
        :where (not (= (conv-type ?pd) 'percent))
        :where (not (is-suppressed ?pd))))

  :constraint
    (let* ((arg-index (compute-arg-index ?fc ?pd))
           (arg-tok   (nth arg-index (arg-tokens ?fc)))
           (actual    (resolve-type arg-tok)))
      (and
        (not (= actual 'unknown))
        (not (is-pointer-type actual))))

  :action
    (let* ((arg-index (compute-arg-index ?fc ?pd))
           (actual    (resolve-type (nth arg-index (arg-tokens ?fc)))))
      (report
        :id       "formatString.FS08"
        :severity error
        :location (location ?fc)
        :message  (format
          "argument ~a to '~a' for specifier '~a' should be a pointer but has type '~a'"
          (+ arg-index 1)
          (callee-name ?fc)
          (raw ?pd)
          actual))))


;;; ═══════════════════════════════════════════════════════════════════
;;; Helper: Argument Index Computation
;;;
;;; Given a call and a directive, compute which variadic argument
;;; index corresponds to that directive, accounting for preceding
;;; directives and their * width/precision arguments.
;;; ═══════════════════════════════════════════════════════════════════

(define-function compute-arg-index (fc pd)
  :doc "Return the 0-based index into (arg-tokens fc) for directive pd's value argument."
  (let* ((all-directives (directives-for fc))
         (preceding      (take-while (lambda (d) (< (position d) (position pd)))
                                     all-directives))
         (consumed-before (sum (args-consumed d) :for-each (d <- preceding)))
         ;; Add * offsets within this directive
         (star-offset    (+ (if (star-width pd) 1 0)
                            (if (star-precision pd) 1 0))))
    (+ consumed-before star-offset)))

(define-function compute-star-arg-index (fc pd)
  :doc "Return the 0-based index for the * width or * precision argument."
  (let* ((all-directives (directives-for fc))
         (preceding      (take-while (lambda (d) (< (position d) (position pd)))
                                     all-directives))
         (consumed-before (sum (args-consumed d) :for-each (d <- preceding))))
    consumed-before))  ;; * args come first, before the value arg

(define-function directives-for (fc)
  :doc "Return all parsed-directive facts for a given format-call."
  (select parsed-directive
    :where (= (call-location _) (location fc))
    :order-by (position _)))


;;; ═══════════════════════════════════════════════════════════════════
;;; Suppression Directives
;;; ═══════════════════════════════════════════════════════════════════

(suppress-on-comment
  :pattern "// NOLINTNEXTLINE(format-string)"
  :scope   next-line
  :rules   (FS01 FS02 FS03 FS04 FS05 FS06 FS07 FS08))

(suppress-on-comment
  :pattern "// NOLINT(format-string)"
  :scope   same-line
  :rules   (FS01 FS02 FS03 FS04 FS05 FS06 FS07 FS08))

(suppress-on-attribute
  :pattern "__attribute__((format(printf, *, *)))"
  :scope   function
  :rules   (FS04)
  :doc     "GCC format attribute implies the developer has marked the function
            as format-aware; suppress non-literal warnings.")


;;; ═══════════════════════════════════════════════════════════════════
;;; Configuration
;;; ═══════════════════════════════════════════════════════════════════

(config
  :max-taint-propagation-depth 20
  :max-string-trace-depth      10
  :user-format-functions-file  "format_functions.txt"
  :user-taint-sources-file     "taint_sources.txt"
  )
