;; ==========================================================================
;; Buflint.casl — Declarative memory-safety checker (CASL equivalent)
;; ==========================================================================
;; This file mirrors the three checks in Buflint.py but uses the CASL
;; pattern/constraint/action model.  Compile with:
;;
;;     casl compile Buflint.casl -o buflint_addon.py
;;
;; Then run:
;;
;;     cppcheck --dump target.c
;;     python buflint_addon.py target.c.dump
;; ==========================================================================

(addon buflint
  (metadata
    (version "1.0.0")
    (description "Memory-safety checker: UAF, Double-Free, Buffer Overflow"))

  ;; -----------------------------------------------------------------------
  ;;  Reusable pattern fragments
  ;; -----------------------------------------------------------------------

  (let-pattern alloc-call
    (or-pattern
      (call (name "malloc")    @size)
      (call (name "calloc")    @nmemb @size)
      (call (name "realloc")   @old   @size)
      (call (name "strdup")    @src)
      (call (name "strndup")   @src   @maxlen)
      (call (name "aligned_alloc") @align @size)))

  (let-pattern dealloc-call
    (or-pattern
      (call (name "free")   @ptr)
      (call (name "cfree")  @ptr)))

  (let-pattern bufwrite-call
    (or-pattern
      (call (name "memcpy")  @dst @src @n)
      (call (name "memmove") @dst @src @n)
      (call (name "memset")  @dst @val @n)
      (call (name "strncpy") @dst @src @n)
      (call (name "strncat") @dst @src @n)
      (call (name "snprintf") @dst @n @fmt)
      (call (name "read")    @fd  @dst @n)
      (call (name "recv")    @fd  @dst @n @flags)))

  ;; -----------------------------------------------------------------------
  ;;  Fact schemas for inter-rule communication
  ;; -----------------------------------------------------------------------

  (fact-schema freed-pointer
    (ptr-var   variable)
    (free-tok  token)
    (free-func string)
    (scope     scope))

  (fact-schema allocated-pointer
    (ptr-var    variable)
    (alloc-tok  token)
    (alloc-func string)
    (byte-count int)
    (scope      scope))

  ;; -----------------------------------------------------------------------
  ;;  Rule 1 — Record every deallocation site
  ;; -----------------------------------------------------------------------

  (rule record-frees
    (pattern
      (expr-stmt
        (use-pattern dealloc-call
          (bind @ptr @free-site))))
    (constraint
      (and
        (pointer-type? @ptr)
        (not (addr-taken? @ptr))))
    (action
      (set-fact freed-pointer
        (ptr-var   @ptr.variable)
        (free-tok  @free-site)
        (free-func @free-site.str)
        (scope     @free-site.scope))))

  ;; -----------------------------------------------------------------------
  ;;  Rule 2 — Record every allocation site
  ;; -----------------------------------------------------------------------

  (rule record-allocs
    (pattern
      (assign @ptr
        (use-pattern alloc-call
          (bind @size @alloc-site))))
    (constraint
      (pointer-type? @ptr))
    (action
      (set-fact allocated-pointer
        (ptr-var    @ptr.variable)
        (alloc-tok  @alloc-site)
        (alloc-func @alloc-site.str)
        (byte-count @size)
        (scope      @alloc-site.scope))))

  ;; -----------------------------------------------------------------------
  ;;  Rule 3 — Use-After-Free
  ;; -----------------------------------------------------------------------

  (rule use-after-free
    (options
      (severity error)
      (scope function))
    (pattern
      ;; Any dereference of a name token: *p, p->x, p[i]
      (or-pattern
        (ast-match (unary-op "*"   @deref-tok))
        (ast-match (binary-op "->" @deref-tok _))
        (ast-match (binary-op "["  @deref-tok _))))
    (constraint
      (and
        ;; There exists a prior free of the same variable …
        (has-fact freed-pointer
          (ptr-var   @deref-tok.variable)
          (free-tok  @free-tok))
        ;; … the free reaches the dereference in the CFG …
        (reaches @free-tok @deref-tok)
        ;; … and on at least one path no intervening re-assignment
        (along-path @free-tok @deref-tok
          (not (contains
            (or-pattern
              (assign @deref-tok.variable _)
              (use-pattern alloc-call
                (bind _ @deref-tok.variable))))))))
    (action
      (report error
        "Use after free: '@deref-tok.str' was freed at @free-tok.file:@free-tok.linenr"
        (location @deref-tok)
        (note "Freed here" (location @free-tok)))))

  ;; -----------------------------------------------------------------------
  ;;  Rule 4 — Double-Free
  ;; -----------------------------------------------------------------------

  (rule double-free
    (options
      (severity error)
      (scope function))
    (pattern
      (expr-stmt
        (use-pattern dealloc-call
          (bind @ptr @second-free))))
    (constraint
      (and
        ;; A prior free of the same variable exists
        (has-fact freed-pointer
          (ptr-var   @ptr.variable)
          (free-tok  @first-free))
        ;; The first free reaches the second
        (reaches @first-free @second-free)
        ;; Not the same token
        (not (same-token? @first-free @second-free))
        ;; No intervening re-allocation or assignment
        (along-path @first-free @second-free
          (not (contains
            (or-pattern
              (assign @ptr.variable _)
              (assign @ptr.variable
                (use-pattern alloc-call))))))))
    (action
      (report error
        "Double free of '@ptr.str'"
        (location @second-free)
        (note "Previously freed here" (location @first-free)))))

  ;; -----------------------------------------------------------------------
  ;;  Rule 5 — Buffer Overflow (static array subscript)
  ;; -----------------------------------------------------------------------

  (rule array-oob-access
    (options
      (severity error)
      (scope function))
    (pattern
      (ast-match
        (binary-op "[" @arr @index)))
    (constraint
      (and
        ;; Array has a known compile-time dimension
        (known-array-size? @arr @capacity)
        ;; Index has a known integer value (or bounded interval)
        (or
          ;; Exact value
          (and
            (known-int-value? @index)
            (or
              (< (int-value @index) 0)
              (>= (int-value @index) @capacity)))
          ;; Interval analysis fallback
          (with-analysis intervals @arr.scope
            (and
              (interval-of @index @lo @hi)
              (or (< @lo 0) (>= @hi @capacity)))))))
    (action
      (report error
        "Out-of-bounds access: '@arr.str' indexed beyond capacity @capacity"
        (location @index)
        (note "Array declared here" (location @arr.variable.nameToken)))))

  ;; -----------------------------------------------------------------------
  ;;  Rule 6 — Buffer Overflow (heap writes via memcpy etc.)
  ;; -----------------------------------------------------------------------

  (rule heap-buffer-overflow-write
    (options
      (severity error)
      (scope function))
    (pattern
      (expr-stmt
        (use-pattern bufwrite-call
          (bind @dst @n @call-tok))))
    (constraint
      (and
        ;; Destination was allocated with a known size
        (has-fact allocated-pointer
          (ptr-var    @dst.variable)
          (byte-count @alloc-bytes))
        ;; Write size exceeds allocation
        (or
          (and
            (known-int-value? @n)
            (> (int-value @n) @alloc-bytes))
          (with-analysis intervals @dst.scope
            (and
              (interval-of @n @lo @hi)
              (> @hi @alloc-bytes))))))
    (action
      (report error
        "Buffer overflow: writing up to @n.str bytes into '@dst.str' (allocated @alloc-bytes bytes)"
        (location @call-tok)
        (note "Allocated here" (location @alloc-tok)))))

) ;; end addon
