#!/usr/bin/env python3
"""
BufferExploitDetect.py  —  Cppcheck addon
==========================================

Detects buffer-related exploit vectors in C programs by combining
**symbolic execution** with **interval-based dataflow analysis**.

The analysis is *sound* in the sense that every reported path is
backed by an SMT-satisfiable path condition (or an interval proof):
if the solver says SAT, the bug is real modulo the model.

Checked CWEs
-------------
  CWE-120  Buffer Copy without Checking Size of Input
  CWE-121  Stack-based Buffer Overflow
  CWE-122  Heap-based Buffer Overflow
  CWE-124  Buffer Underwrite ('Buffer Underflow')
  CWE-125  Out-of-bounds Read
  CWE-126  Buffer Over-read
  CWE-127  Buffer Under-read
  CWE-131  Incorrect Calculation of Buffer Size
  CWE-170  Improper Null Termination
  CWE-787  Out-of-bounds Write
  CWE-805  Buffer Access with Incorrect Length Value
  CWE-806  Buffer Access Using Size of Source Buffer

Requires
--------
- cppcheckdata  (ships with Cppcheck)
- cppcheckdata_shims.symbolic_exec
- cppcheckdata_shims.dataflow_engine

Usage
-----
    cppcheck --dump myfile.c
    python BufferExploitDetect.py myfile.c.dump
"""

from __future__ import annotations

import sys
import os
import copy
from collections import defaultdict
from dataclasses import dataclass, field
from typing import (
    Any,
    Dict,
    FrozenSet,
    List,
    Optional,
    Set,
    Tuple,
    Union,
)

# ── cppcheck data model ──────────────────────────────────────────────
import cppcheckdata

# ── symbolic execution engine ────────────────────────────────────────
from cppcheckdata_shims.symbolic_exec import (
    SymExpr,
    SymConst,
    SymVar,
    SymBinOp,
    SymUnaryOp,
    SymITE,
    SymMemoryRead,
    SymFunctionApp,
    SymExprKind,
    SymState,
    PathCondition,
    SymbolicExecutor,
    StaticSymbolicExecutor,
    ConcolicExecutor,
    ExplorationStrategy,
    SMTSolver,
    InternalSimplifier,
    Z3Backend,
    PathResult,
    TestCase,
    SymExprBuilder,
    execute_function,
    execute_path,
    find_bug_triggering_inputs,
    find_assertion_violations,
    sym_expr_size,
    sym_expr_depth,
    collect_all_constraints,
    BUILTIN_FUNCTION_MODELS,
    DEFAULT_MAX_PATHS,
    DEFAULT_MAX_DEPTH,
    DEFAULT_LOOP_BOUND,
    DEFAULT_TIMEOUT_SECONDS,
)

# ── dataflow engine (interval lattice for buffer-size reasoning) ─────
from cppcheckdata_shims.dataflow_engine import (
    Lattice,
    Direction,
    WorklistStrategy,
    IntervalLattice,
    MapLattice,
    PowersetLattice,
    FlatLattice,
    SignLattice,
    Sign,
    ProductLattice,
    TopBottomLattice,
    DataflowResult,
    NEG_INF,
    POS_INF,
)

# =====================================================================
#  CONFIGURATION
# =====================================================================

MAX_SYM_PATHS = 2000           # per-function symbolic-path budget
SYM_TIMEOUT   = 120.0          # per-function timeout (seconds)
LOOP_UNROLL   = 8              # bounded loop unrolling depth
INTERVAL_WIDEN_THRESHOLDS = [0, 1, 8, 16, 32, 64, 128, 256,
                             512, 1024, 4096, 65536]

# =====================================================================
#  DANGEROUS FUNCTION DATABASES
# =====================================================================

# Functions that copy data into a destination buffer.
# key → (dst_param_index, src_param_index_or_None, size_param_index_or_None)
# Indices are 0-based.
COPY_FUNCTIONS: Dict[str, Tuple[int, Optional[int], Optional[int]]] = {
    "strcpy":    (0, 1, None),
    "strncpy":   (0, 1, 2),
    "strcat":    (0, 1, None),
    "strncat":   (0, 1, 2),
    "memcpy":    (0, 1, 2),
    "memmove":   (0, 1, 2),
    "memset":    (0, None, 2),
    "sprintf":   (0, None, None),
    "vsprintf":  (0, None, None),
    "gets":      (0, None, None),
    "wcscpy":    (0, 1, None),
    "wcsncpy":   (0, 1, 2),
    "wcscat":    (0, 1, None),
    "wcsncat":   (0, 1, 2),
    "wmemcpy":   (0, 1, 2),
    "wmemmove":  (0, 1, 2),
}

# Functions that read from a buffer.
# key → (buf_param_index, size_param_index_or_None)
READ_FUNCTIONS: Dict[str, Tuple[int, Optional[int]]] = {
    "memcmp":  (0, 2),
    "strncmp": (0, 2),
    "strlen":  (0, None),
    "strnlen": (0, 1),
    "fread":   (0, None),
    "fwrite":  (0, None),
    "read":    (1, 2),
    "write":   (1, 2),
    "recv":    (1, 2),
    "send":    (1, 2),
}

# Allocation functions → (returns_pointer, size_param_index)
ALLOC_FUNCTIONS: Dict[str, int] = {
    "malloc":   0,
    "calloc":   1,    # calloc(nmemb, size) → total = nmemb * size
    "realloc":  1,
    "alloca":   0,
    "aligned_alloc": 1,
}

# =====================================================================
#  DATA STRUCTURES
# =====================================================================

@dataclass
class BufferInfo:
    """Tracks what we know about a buffer (array / heap allocation)."""
    name: str                      # variable / token name
    alloc_size_expr: SymExpr       # symbolic size in *bytes*
    alloc_size_interval: Tuple[float, float] = (0.0, POS_INF)
    element_size: int = 1          # sizeof element type (best guess)
    is_stack: bool = True          # True → stack, False → heap
    is_null_terminated: bool = False
    decl_token: Any = None         # Cppcheck Token of the declaration
    alloc_token: Any = None        # Token of the allocation call


@dataclass
class AccessInfo:
    """A single buffer access (read or write) that we want to validate."""
    buffer_name: str
    index_expr: SymExpr            # symbolic index into the buffer
    access_size_expr: SymExpr      # how many bytes are accessed
    is_write: bool
    token: Any                     # Cppcheck Token at the access site
    function_name: Optional[str] = None  # if the access is via a library call


@dataclass
class BufExploitFinding:
    """A single reported finding."""
    cwe: int
    severity: str          # "error" | "warning" | "style"
    message: str
    file: str
    line: int
    column: int = 0
    test_case: Optional[TestCase] = None   # witness inputs (if available)
    path_condition: Optional[PathCondition] = None

    def cppcheck_report(self, data: cppcheckdata) -> None:
        """Emit the finding through cppcheckdata.reportError."""
        cppcheckdata.reportError(
            token=None,
            severity=self.severity,
            msg=f"[CWE-{self.cwe}] {self.message}",
            addon="BufferExploitDetect",
            errorId=f"bufferExploit_CWE{self.cwe}",
            extra=f"file={self.file}:line={self.line}",
        )


# =====================================================================
#  BUFFER-SIZE INTERVAL LATTICE
# =====================================================================

class BufferSizeLattice(IntervalLattice):
    """Specialised interval lattice for buffer sizes.

    Adds widening thresholds common in buffer-size reasoning (powers of
    two, page sizes, etc.) and a helper to check whether an access
    interval lies within an allocation interval.
    """

    def __init__(self) -> None:
        super().__init__(thresholds=INTERVAL_WIDEN_THRESHOLDS)

    def access_may_overflow(
        self,
        buf_size: Tuple[float, float],
        access_offset: Tuple[float, float],
        access_length: Tuple[float, float],
    ) -> bool:
        """Return True when *access_offset + access_length* may exceed
        *buf_size*.  This is a sound (may) over-approximation."""
        # end = offset + length
        end_lo = access_offset[0] + access_length[0]
        end_hi = access_offset[1] + access_length[1]
        # overflow iff end_hi > buf_size[0]  (worst case: smallest buf,
        # largest end)
        return end_hi > buf_size[0]

    def access_may_underflow(
        self,
        access_offset: Tuple[float, float],
    ) -> bool:
        """Return True when *access_offset* may be negative."""
        return access_offset[0] < 0


# =====================================================================
#  SYMBOLIC MODELS FOR DANGEROUS FUNCTIONS
# =====================================================================

def _model_strlen(
    state: SymState, args: List[SymExpr]
) -> Tuple[SymState, SymExpr]:
    """Symbolic model: strlen returns a non-negative symbolic value ≤
    buffer size - 1."""
    if not args:
        return state, SymVar("__strlen_unknown__")
    # Return an unconstrained non-negative symbolic value
    result = SymVar("__strlen_ret__", version=state.fresh_call_id())
    # We could add a constraint result >= 0, but the InternalSimplifier
    # treats unknowns conservatively.
    return state, result


def _model_sizeof(
    state: SymState, args: List[SymExpr]
) -> Tuple[SymState, SymExpr]:
    """Symbolic model for sizeof (if encountered as a call)."""
    if not args:
        return state, SymConst(1)
    return state, args[0]


BUFFER_FUNCTION_MODELS = dict(BUILTIN_FUNCTION_MODELS)
BUFFER_FUNCTION_MODELS["strlen"] = _model_strlen
BUFFER_FUNCTION_MODELS["sizeof"] = _model_sizeof


# =====================================================================
#  HELPER: TOKEN WALKING
# =====================================================================

def _tok_str(tok) -> str:
    """Safely get the string of a token."""
    return getattr(tok, "str", "") if tok else ""


def _tok_line(tok) -> int:
    return getattr(tok, "linenr", 0) if tok else 0


def _tok_col(tok) -> int:
    return getattr(tok, "column", 0) if tok else 0


def _tok_file(tok) -> str:
    f = getattr(tok, "file", None)
    if f:
        return str(f)
    return "<unknown>"


def _get_var_name(tok) -> Optional[str]:
    """Get the variable name from a token, chasing through variable obj."""
    var = getattr(tok, "variable", None)
    if var is not None:
        nt = getattr(var, "nameToken", None)
        if nt:
            return _tok_str(nt)
    if getattr(tok, "isName", False):
        return _tok_str(tok)
    return None


def _is_subscript(tok) -> bool:
    """Return True if *tok* is the '[' of an array subscript."""
    return _tok_str(tok) == "["


def _is_deref(tok) -> bool:
    """Return True if *tok* is a pointer dereference '*ptr'."""
    return (_tok_str(tok) == "*"
            and getattr(tok, "astOperand1", None) is not None
            and getattr(tok, "astOperand2", None) is None)


def _is_call(tok) -> bool:
    """Return True if *tok* is a function-call '('."""
    return (_tok_str(tok) == "("
            and getattr(tok, "astOperand1", None) is not None)


def _call_name(tok) -> Optional[str]:
    """Return the callee name of a call token, or None."""
    if not _is_call(tok):
        return None
    callee = getattr(tok, "astOperand1", None)
    if callee is None:
        return None
    return _tok_str(callee)


def _call_args(tok) -> List:
    """Return the list of argument tokens for a call token.

    Arguments are chained via comma operators on astOperand2.
    """
    args_tok = getattr(tok, "astOperand2", None)
    if args_tok is None:
        return []
    return _flatten_comma(args_tok)


def _flatten_comma(tok) -> List:
    """Recursively flatten comma-separated argument tokens."""
    if tok is None:
        return []
    if _tok_str(tok) == ",":
        left = getattr(tok, "astOperand1", None)
        right = getattr(tok, "astOperand2", None)
        return _flatten_comma(left) + _flatten_comma(right)
    return [tok]


# =====================================================================
#  PHASE 1 — COLLECT BUFFER DECLARATIONS & ALLOCATIONS
# =====================================================================

def _collect_buffers(cfg, scope) -> Dict[str, BufferInfo]:
    """Walk variables in the function scope and identify declared arrays
    and heap-allocated buffers."""
    buffers: Dict[str, BufferInfo] = {}

    # ── Declared local arrays (int buf[N]) ────────────────────────
    for var in getattr(scope, "varlist", []):
        if var is None:
            continue
        is_array = getattr(var, "isArray", False)
        if not is_array:
            continue
        name_tok = getattr(var, "nameToken", None)
        name = _tok_str(name_tok) if name_tok else None
        if not name:
            continue

        # Try to extract declared size
        dim = getattr(var, "dimension", None)  # list of dimensions
        type_tok = getattr(var, "typeStartToken", None)

        # Guess element size from type
        elem_size = _guess_element_size(var)

        total_sym: SymExpr
        total_interval: Tuple[float, float]

        if dim and isinstance(dim, (list, tuple)) and len(dim) > 0:
            total_elements = 1
            for d in dim:
                dd = int(d) if d else 0
                total_elements *= dd
            total_bytes = total_elements * elem_size
            total_sym = SymConst(total_bytes)
            total_interval = (float(total_bytes), float(total_bytes))
        else:
            # Unknown size
            total_sym = SymVar(f"__sizeof_{name}__")
            total_interval = (0.0, POS_INF)

        buffers[name] = BufferInfo(
            name=name,
            alloc_size_expr=total_sym,
            alloc_size_interval=total_interval,
            element_size=elem_size,
            is_stack=True,
            decl_token=name_tok,
        )

    return buffers


def _guess_element_size(var) -> int:
    """Heuristic: guess element size from type tokens."""
    type_start = getattr(var, "typeStartToken", None)
    type_end = getattr(var, "typeEndToken", None)
    tok = type_start
    while tok is not None:
        s = _tok_str(tok)
        if s in ("char", "int8_t", "uint8_t"):
            return 1
        if s in ("short", "int16_t", "uint16_t"):
            return 2
        if s in ("int", "int32_t", "uint32_t", "float"):
            return 4
        if s in ("long", "int64_t", "uint64_t", "double", "size_t"):
            return 8
        if s in ("wchar_t",):
            return 4
        if tok is type_end:
            break
        tok = getattr(tok, "next", None)
    return 1   # default: byte-sized


# =====================================================================
#  PHASE 2 — COLLECT BUFFER ACCESSES (subscripts + library calls)
# =====================================================================

def _collect_accesses(
    token_list, buffers: Dict[str, BufferInfo], sym_state: SymState,
) -> List[AccessInfo]:
    """Walk all tokens and record every access to a known buffer."""
    accesses: List[AccessInfo] = []
    builder = SymExprBuilder(sym_state)

    tok = token_list
    while tok is not None:
        # ── 2a. Array subscript: buf[i] ──────────────────────────
        if _is_subscript(tok):
            base_tok = getattr(tok, "astOperand1", None)
            index_tok = getattr(tok, "astOperand2", None)
            buf_name = _get_var_name(base_tok)
            if buf_name and buf_name in buffers:
                elem_sz = buffers[buf_name].element_size
                index_sym = builder.build(index_tok)
                # byte offset = index * elem_size
                offset_sym = SymBinOp("*", index_sym, SymConst(elem_sz))
                # Determine if this is a read or write
                parent = getattr(tok, "astParent", None)
                is_write = (parent is not None and
                            _tok_str(parent) in ("=", "+=", "-=",
                                                  "*=", "/=", "%=",
                                                  "&=", "|=", "^=",
                                                  "<<=", ">>=")
                            and getattr(parent, "astOperand1", None) is tok)
                accesses.append(AccessInfo(
                    buffer_name=buf_name,
                    index_expr=offset_sym,
                    access_size_expr=SymConst(elem_sz),
                    is_write=is_write,
                    token=tok,
                ))

        # ── 2b. Dangerous library call ───────────────────────────
        if _is_call(tok):
            fname = _call_name(tok)
            args = _call_args(tok)

            # Copy functions (CWE-120, CWE-121, CWE-122, CWE-787)
            if fname and fname in COPY_FUNCTIONS:
                dst_idx, src_idx, sz_idx = COPY_FUNCTIONS[fname]
                dst_name = _get_var_name(args[dst_idx]) if dst_idx < len(args) else None
                if dst_name and dst_name in buffers:
                    if sz_idx is not None and sz_idx < len(args):
                        sz_sym = builder.build(args[sz_idx])
                    elif src_idx is not None and src_idx < len(args):
                        # unbounded copy — size is strlen(src) + 1
                        src_sym = builder.build(args[src_idx])
                        sz_sym = SymBinOp("+",
                                          SymFunctionApp("strlen", (src_sym,)),
                                          SymConst(1))
                    else:
                        # completely unbounded (gets, sprintf)
                        sz_sym = SymVar(f"__ext_input_len_{fname}__")

                    accesses.append(AccessInfo(
                        buffer_name=dst_name,
                        index_expr=SymConst(0),
                        access_size_expr=sz_sym,
                        is_write=True,
                        token=tok,
                        function_name=fname,
                    ))

            # Read functions (CWE-125, CWE-126, CWE-127)
            if fname and fname in READ_FUNCTIONS:
                buf_idx, sz_idx = READ_FUNCTIONS[fname]
                rd_name = _get_var_name(args[buf_idx]) if buf_idx < len(args) else None
                if rd_name and rd_name in buffers:
                    if sz_idx is not None and sz_idx < len(args):
                        sz_sym = builder.build(args[sz_idx])
                    else:
                        sz_sym = SymVar(f"__read_len_{fname}__")
                    accesses.append(AccessInfo(
                        buffer_name=rd_name,
                        index_expr=SymConst(0),
                        access_size_expr=sz_sym,
                        is_write=False,
                        token=tok,
                        function_name=fname,
                    ))

        # ── 2c. Heap allocation tracking ─────────────────────────
        if _is_call(tok):
            fname = _call_name(tok)
            args = _call_args(tok)
            if fname and fname in ALLOC_FUNCTIONS:
                sz_param_idx = ALLOC_FUNCTIONS[fname]
                parent = getattr(tok, "astParent", None)
                # Look for  ptr = malloc(...)
                if parent is not None and _tok_str(parent) == "=":
                    lhs = getattr(parent, "astOperand1", None)
                    lhs_name = _get_var_name(lhs)
                    if lhs_name and sz_param_idx < len(args):
                        sz_sym = builder.build(args[sz_param_idx])
                        # calloc is special: size = arg0 * arg1
                        if fname == "calloc" and len(args) >= 2:
                            nmemb_sym = builder.build(args[0])
                            sz_sym = SymBinOp("*", nmemb_sym, sz_sym)
                        # Evaluate interval
                        iv = _sym_to_interval(sz_sym)
                        buffers[lhs_name] = BufferInfo(
                            name=lhs_name,
                            alloc_size_expr=sz_sym,
                            alloc_size_interval=iv,
                            element_size=1,
                            is_stack=False,
                            alloc_token=tok,
                        )

        tok = getattr(tok, "next", None)

    return accesses


def _sym_to_interval(expr: SymExpr) -> Tuple[float, float]:
    """Quick symbolic-to-interval extraction.  Concrete constants give
    exact intervals; everything else maps to [0, +∞)."""
    if expr.is_concrete:
        v = float(expr.concrete_value)
        return (v, v)
    return (0.0, POS_INF)


# =====================================================================
#  PHASE 3 — SYMBOLIC VALIDATION OF EACH ACCESS
# =====================================================================

def _validate_accesses_symbolic(
    cfg,
    accesses: List[AccessInfo],
    buffers: Dict[str, BufferInfo],
) -> List[BufExploitFinding]:
    """For every collected access, use symbolic execution to check whether
    the path condition allows the index to exceed the buffer size."""
    findings: List[BufExploitFinding] = []
    solver = InternalSimplifier()

    # Attempt to get Z3 for higher precision
    try:
        solver = Z3Backend()
    except Exception:
        solver = InternalSimplifier()

    buf_lattice = BufferSizeLattice()

    for acc in accesses:
        binfo = buffers.get(acc.buffer_name)
        if binfo is None:
            continue

        # Build the overflow / underflow constraint symbolically
        # end_offset = index_expr + access_size_expr
        end_offset = SymBinOp("+", acc.index_expr, acc.access_size_expr)

        # --- overflow check: end_offset > alloc_size ---
        overflow_cond = SymBinOp(">", end_offset, binfo.alloc_size_expr)
        overflow_pc = PathCondition([overflow_cond])
        overflow_result = solver.check_sat(overflow_pc)

        # --- underflow check: index_expr < 0 ---
        underflow_cond = SymBinOp("<", acc.index_expr, SymConst(0))
        underflow_pc = PathCondition([underflow_cond])
        underflow_result = solver.check_sat(underflow_pc)

        tok = acc.token
        file_name = _tok_file(tok)
        line = _tok_line(tok)
        col = _tok_col(tok)

        # Also check with interval arithmetic as a fast path
        acc_offset_iv = _sym_to_interval(acc.index_expr)
        acc_length_iv = _sym_to_interval(acc.access_size_expr)
        buf_size_iv = binfo.alloc_size_interval

        interval_overflow = buf_lattice.access_may_overflow(
            buf_size_iv, acc_offset_iv, acc_length_iv
        )
        interval_underflow = buf_lattice.access_may_underflow(acc_offset_iv)

        # ── Report overflow ──────────────────────────────────────
        from_solver = (overflow_result is not None
                       and str(overflow_result) != "UNSAT")
        if interval_overflow or from_solver:
            cwe, msg = _classify_overflow(acc, binfo)
            tc = None
            if from_solver:
                model = solver.get_model(overflow_pc)
                if model is not None:
                    tc = TestCase(
                        inputs=dict(model.assignments),
                        path=[],
                        path_condition=overflow_pc,
                    )
            findings.append(BufExploitFinding(
                cwe=cwe,
                severity="error",
                message=msg,
                file=file_name,
                line=line,
                column=col,
                test_case=tc,
                path_condition=overflow_pc,
            ))

        # ── Report underflow ─────────────────────────────────────
        from_solver_under = (underflow_result is not None
                             and str(underflow_result) != "UNSAT")
        if interval_underflow or from_solver_under:
            cwe, msg = _classify_underflow(acc, binfo)
            tc = None
            if from_solver_under:
                model = solver.get_model(underflow_pc)
                if model is not None:
                    tc = TestCase(
                        inputs=dict(model.assignments),
                        path=[],
                        path_condition=underflow_pc,
                    )
            findings.append(BufExploitFinding(
                cwe=cwe,
                severity="error",
                message=msg,
                file=file_name,
                line=line,
                column=col,
                test_case=tc,
                path_condition=underflow_pc,
            ))

    # ── 'gets' is *always* exploitable (CWE-120) ────────────────
    for acc in accesses:
        if acc.function_name == "gets":
            tok = acc.token
            findings.append(BufExploitFinding(
                cwe=120,
                severity="error",
                message=(f"Use of gets() with buffer '{acc.buffer_name}' "
                         f"is always exploitable — CWE-120"),
                file=_tok_file(tok),
                line=_tok_line(tok),
                column=_tok_col(tok),
            ))

    return findings


# =====================================================================
#  PHASE 4 — FULL PATH-SENSITIVE SYMBOLIC EXPLORATION
# =====================================================================

def _validate_full_symbolic(
    cfg,
    function,
    buffers: Dict[str, BufferInfo],
) -> List[BufExploitFinding]:
    """Run SymbolicExecutor on the function's CFG and examine each path
    result for buffer errors.

    This phase catches inter-procedural or path-dependent overflows
    that the per-access check (Phase 3) might miss.
    """
    findings: List[BufExploitFinding] = []
    if cfg is None:
        return findings

    try:
        solver = Z3Backend()
    except Exception:
        solver = InternalSimplifier()

    # Build function models that include our buffer models
    all_models = dict(BUFFER_FUNCTION_MODELS)

    path_results = execute_function(
        cfg,
        solver=solver,
        strategy=ExplorationStrategy.COVERAGE,
        max_paths=MAX_SYM_PATHS,
        max_depth=DEFAULT_MAX_DEPTH,
        loop_bound=LOOP_UNROLL,
        timeout=SYM_TIMEOUT,
        function_models=all_models,
        check_assertions=True,
        check_division_by_zero=True,
        generate_tests=True,
    )

    for pr in path_results:
        if not pr.is_error:
            continue

        tok = pr.error_token
        cwe = 787  # default: out-of-bounds write
        if pr.error_kind == "assertion_violation":
            # Could be a bounds-check assertion
            cwe = 787
        elif pr.error_kind == "array_out_of_bounds":
            cwe = 787
        elif pr.error_kind == "division_by_zero":
            # Not directly a buffer bug, but may indicate CWE-131
            # (incorrect buffer size calculation)
            cwe = 131

        findings.append(BufExploitFinding(
            cwe=cwe,
            severity="error",
            message=(f"Symbolic execution detected '{pr.error_kind}': "
                     f"{pr.error_message}"),
            file=_tok_file(tok) if tok else "<unknown>",
            line=_tok_line(tok) if tok else 0,
            column=_tok_col(tok) if tok else 0,
            test_case=pr.test_case,
            path_condition=pr.path_condition,
        ))

    return findings


# =====================================================================
#  PHASE 5 — SIZE-MISMATCH HEURISTICS (CWE-131, CWE-805, CWE-806)
# =====================================================================

def _check_size_mismatches(
    token_list,
    buffers: Dict[str, BufferInfo],
    sym_state: SymState,
) -> List[BufExploitFinding]:
    """Detect incorrect buffer-size calculations:

    - CWE-131  malloc(n) where n doesn't account for element size
    - CWE-805  Buffer Access with Incorrect Length Value
    - CWE-806  Buffer Access Using Size of Source Buffer
    """
    findings: List[BufExploitFinding] = []
    builder = SymExprBuilder(sym_state)

    tok = token_list
    while tok is not None:
        if _is_call(tok):
            fname = _call_name(tok)
            args = _call_args(tok)

            # ── CWE-806: sizeof(src) used as the length arg of a copy ──
            if fname in COPY_FUNCTIONS:
                dst_idx, src_idx, sz_idx = COPY_FUNCTIONS[fname]
                if sz_idx is not None and sz_idx < len(args):
                    sz_tok = args[sz_idx]
                    # Check if size argument is sizeof(src) rather than
                    # sizeof(dst)
                    if _tok_str(sz_tok) == "(" and _call_name(sz_tok) is None:
                        inner = getattr(sz_tok, "astOperand1", None)
                        if inner and _tok_str(inner) == "sizeof":
                            sizeof_arg = getattr(inner, "astOperand2", None)
                            sizeof_name = _get_var_name(sizeof_arg)
                            src_name = (_get_var_name(args[src_idx])
                                        if src_idx is not None
                                        and src_idx < len(args) else None)
                            dst_name = (_get_var_name(args[dst_idx])
                                        if dst_idx < len(args) else None)
                            if (sizeof_name and src_name
                                    and sizeof_name == src_name
                                    and sizeof_name != dst_name):
                                findings.append(BufExploitFinding(
                                    cwe=806,
                                    severity="warning",
                                    message=(
                                        f"sizeof(source) '{sizeof_name}' "
                                        f"used as length in {fname}() "
                                        f"instead of sizeof(dest) — CWE-806"),
                                    file=_tok_file(tok),
                                    line=_tok_line(tok),
                                    column=_tok_col(tok),
                                ))

            # ── CWE-131: malloc(count) without multiplying by elem size ──
            if fname in ALLOC_FUNCTIONS and fname != "calloc":
                sz_param_idx = ALLOC_FUNCTIONS[fname]
                if sz_param_idx < len(args):
                    sz_tok = args[sz_param_idx]
                    sz_sym = builder.build(sz_tok)
                    # If the size expression is just a simple variable /
                    # constant without any multiplication, it *might* be
                    # wrong for non-char types.
                    if (isinstance(sz_sym, (SymVar, SymConst))
                            and not isinstance(sz_sym, SymBinOp)):
                        # Check if the result is used as a typed pointer
                        parent = getattr(tok, "astParent", None)
                        if parent and _tok_str(parent) == "=":
                            lhs = getattr(parent, "astOperand1", None)
                            if lhs:
                                lvar = getattr(lhs, "variable", None)
                                if lvar:
                                    esz = _guess_element_size(lvar)
                                    if esz > 1:
                                        findings.append(BufExploitFinding(
                                            cwe=131,
                                            severity="warning",
                                            message=(
                                                f"{fname}() size argument "
                                                f"may not account for "
                                                f"element size ({esz}) "
                                                f"— CWE-131"),
                                            file=_tok_file(tok),
                                            line=_tok_line(tok),
                                            column=_tok_col(tok),
                                        ))

        tok = getattr(tok, "next", None)

    return findings


# =====================================================================
#  PHASE 6 — NULL-TERMINATION CHECK (CWE-170)
# =====================================================================

def _check_null_termination(
    token_list,
    buffers: Dict[str, BufferInfo],
) -> List[BufExploitFinding]:
    """Detect improper null termination after strncpy / memcpy.

    strncpy does **not** guarantee null termination when
    len(src) >= n.  If no explicit '\\0' is written afterwards,
    report CWE-170.
    """
    findings: List[BufExploitFinding] = []
    # Track buffers that were strncpy'd into without subsequent '\0'
    strncpy_targets: Dict[str, Any] = {}  # name → token

    tok = token_list
    while tok is not None:
        if _is_call(tok):
            fname = _call_name(tok)
            args = _call_args(tok)

            if fname in ("strncpy", "wcsncpy") and len(args) >= 1:
                dst_name = _get_var_name(args[0])
                if dst_name:
                    strncpy_targets[dst_name] = tok

            # If we later see  buf[n-1] = '\0'  or  buf[n] = 0 etc.
            # we clear the flag.  (Simple heuristic: any assignment to
            # the buffer with a zero RHS.)
        elif _is_subscript(tok):
            base_tok = getattr(tok, "astOperand1", None)
            buf_name = _get_var_name(base_tok)
            if buf_name and buf_name in strncpy_targets:
                parent = getattr(tok, "astParent", None)
                if parent and _tok_str(parent) == "=":
                    rhs = getattr(parent, "astOperand2", None)
                    if rhs and _tok_str(rhs) in ("0", "'\\0'"):
                        del strncpy_targets[buf_name]

        tok = getattr(tok, "next", None)

    for name, call_tok in strncpy_targets.items():
        findings.append(BufExploitFinding(
            cwe=170,
            severity="warning",
            message=(
                f"Buffer '{name}' filled by strncpy/wcsncpy without "
                f"guaranteed null termination — CWE-170"),
            file=_tok_file(call_tok),
            line=_tok_line(call_tok),
            column=_tok_col(call_tok),
        ))

    return findings


# =====================================================================
#  CWE CLASSIFICATION
# =====================================================================

def _classify_overflow(
    acc: AccessInfo, binfo: BufferInfo
) -> Tuple[int, str]:
    """Choose the right CWE for an overflow and build the message."""
    fname = acc.function_name or ""

    if fname == "gets":
        return 120, (f"Buffer '{binfo.name}' overflow via gets() — CWE-120")

    if fname in ("strcpy", "strcat", "sprintf", "vsprintf",
                 "wcscpy", "wcscat"):
        return 120, (
            f"Buffer '{binfo.name}' overflow via unbounded {fname}() "
            f"— CWE-120 (Buffer Copy without Checking Size)")

    if binfo.is_stack:
        cwe = 121  # stack overflow
        loc = "stack"
    else:
        cwe = 122  # heap overflow
        loc = "heap"

    if acc.is_write:
        cwe_alt = 787  # out-of-bounds write
    else:
        cwe_alt = 125  # out-of-bounds read
        if binfo.is_stack:
            cwe_alt = 126  # buffer over-read

    # Prefer the more specific CWE
    if acc.function_name:
        return cwe, (
            f"{loc.title()}-based buffer '{binfo.name}' overflow in "
            f"{acc.function_name}() — CWE-{cwe}")
    return cwe_alt, (
        f"Out-of-bounds {'write' if acc.is_write else 'read'} on "
        f"{loc} buffer '{binfo.name}' — CWE-{cwe_alt}")


def _classify_underflow(
    acc: AccessInfo, binfo: BufferInfo
) -> Tuple[int, str]:
    """Choose the right CWE for an underflow."""
    if acc.is_write:
        return 124, (
            f"Buffer underwrite on '{binfo.name}' — CWE-124 "
            f"(Buffer Underflow)")
    return 127, (
        f"Buffer under-read on '{binfo.name}' — CWE-127")


# =====================================================================
#  MAIN DRIVER
# =====================================================================

def analyse_function(
    cfg, scope, function, token_list
) -> List[BufExploitFinding]:
    """Run all phases of the buffer-exploit analysis on one function."""
    findings: List[BufExploitFinding] = []

    # Phase 1 — collect buffers
    buffers = _collect_buffers(cfg, scope)

    # Build a baseline symbolic state for expression building
    sym_state = SymState()

    # Phase 2 — collect accesses
    accesses = _collect_accesses(token_list, buffers, sym_state)

    # Phase 3 — per-access symbolic validation
    findings.extend(
        _validate_accesses_symbolic(cfg, accesses, buffers)
    )

    # Phase 4 — full-function symbolic exploration
    findings.extend(
        _validate_full_symbolic(cfg, function, buffers)
    )

    # Phase 5 — size-mismatch heuristics
    findings.extend(
        _check_size_mismatches(token_list, buffers, sym_state)
    )

    # Phase 6 — null-termination check
    findings.extend(
        _check_null_termination(token_list, buffers)
    )

    return findings


def run_on_dump(dump_file: str) -> List[BufExploitFinding]:
    """Analyse a single Cppcheck .dump file.

    Parameters
    ----------
    dump_file : str
        Path to the ``*.c.dump`` file produced by ``cppcheck --dump``.

    Returns
    -------
    list[BufExploitFinding]
    """
    data = cppcheckdata.CppcheckData(dump_file)
    all_findings: List[BufExploitFinding] = []

    for cfg in data.iterconfigurations():
        for scope in cfg.scopes:
            if scope.type != "Function":
                continue
            func = scope.function
            if func is None:
                continue

            token_list = getattr(scope, "bodyStart", None)
            if token_list is None:
                token_list = cfg.tokenlist

            func_cfg = getattr(func, "cfg", None)

            findings = analyse_function(
                func_cfg, scope, func, token_list
            )
            all_findings.extend(findings)

    return all_findings


def main() -> None:
    """CLI entry point."""
    if len(sys.argv) < 2:
        print("Usage: python BufferExploitDetect.py <file.c.dump> [...]",
              file=sys.stderr)
        sys.exit(1)

    exit_code = 0
    for dump_path in sys.argv[1:]:
        if not os.path.isfile(dump_path):
            print(f"Error: '{dump_path}' not found", file=sys.stderr)
            exit_code = 1
            continue

        findings = run_on_dump(dump_path)
        for f in findings:
            tag = f"[CWE-{f.cwe}]"
            witness = ""
            if f.test_case is not None:
                witness = f"  witness={f.test_case}"
            print(f"{f.file}:{f.line}:{f.column}: {f.severity}: "
                  f"{tag} {f.message}{witness}")
        if findings:
            exit_code = 1

    sys.exit(exit_code)


if __name__ == "__main__":
    main()
